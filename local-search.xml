<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/27/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84py%E5%BA%93/"/>
    <url>/2024/10/27/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84py%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="python库"><a href="#python库" class="headerlink" title="python库"></a>python库</h1><h2 id="1-request"><a href="#1-request" class="headerlink" title="1.request"></a>1.request</h2><p><a href="https://requests.readthedocs.io/en/latest/user/quickstart/#make-a-request">快速入门 — 请求 2.32.3 文档 (requests.readthedocs.io)</a></p><h3 id="发送get请求"><a href="#发送get请求" class="headerlink" title="发送get请求"></a>发送get请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">requests.get(url, params=<span class="hljs-literal">None</span>, **kwargs)<br><span class="hljs-string">&#x27;&#x27;&#x27;Sends a GET request.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :param url: URL for the new :class:`Request` object.</span><br><span class="hljs-string">    :param params: (optional) Dictionary, list of tuples or bytes to send</span><br><span class="hljs-string">        in the query string for the :class:`Request`.</span><br><span class="hljs-string">    :param \*\*kwargs: Optional arguments that ``request`` takes.</span><br><span class="hljs-string">    :return: :class:`Response &lt;Response&gt;` object</span><br><span class="hljs-string">    :rtype: requests.Response&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>常见**kwargs参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>header</code></td><td>dict</td><td></td></tr><tr><td><code>cookies</code></td><td>dict或 <code>RequestsCookieJar</code> 对象</td><td></td></tr><tr><td><code>auth</code></td><td>tuple或 <code>requests.auth.HTTPBasicAuth</code> 对象</td><td><strong>作用</strong>：用于 HTTP 基本认证。</td></tr><tr><td><code>allow_redirects</code></td><td>bool</td><td><strong>作用</strong>：是否允许自动重定向。  <strong>默认值</strong>：<code>True</code></td></tr><tr><td>timeout</td><td>int&#x2F;double&#x2F;tuple</td><td><strong>作用</strong>：设置请求超时时间（以秒为单位），可以是连接超时，也可以是读取超时，或者两者的元组。</td></tr></tbody></table><h2 id="2-json"><a href="#2-json" class="headerlink" title="2.json"></a>2.json</h2><p><a href="https://www.json.org/json-en.html">JSON</a></p><h2 id="3-plotly"><a href="#3-plotly" class="headerlink" title="3.plotly"></a>3.plotly</h2><p><a href="https://plotly.com/python/plotly-express/">用 Python plotly express</a></p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> plotly <span class="hljs-keyword">import</span> express <span class="hljs-keyword">as</span> px<br>fig = px.bar(x=[],y=[],title=<span class="hljs-string">&quot;&quot;</span>,label=&#123;<span class="hljs-string">&#x27;x&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span>&#125;)<br>fig.show()<br></code></pre></td></tr></table></figure><h3 id="定制外观"><a href="#定制外观" class="headerlink" title="定制外观"></a>定制外观</h3><h4 id="设置图片样式"><a href="#设置图片样式" class="headerlink" title="设置图片样式"></a>设置图片样式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig.update_layout(title_font_size= ,xaxis_title_font_size= ,yaxis_title_font_size= )<br></code></pre></td></tr></table></figure><h4 id="添加工具提示"><a href="#添加工具提示" class="headerlink" title="添加工具提示"></a>添加工具提示</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">hover_texts = []<br><br>...<br>hover_text = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;python变量&#125;</span>&lt;br/&gt;<span class="hljs-subst">&#123;python变量&#125;</span>&#x27;</span><br><span class="hljs-comment">#f&#x27;&#x27; 使用HTML语法，当要插入python变量时用&#123;python变量&#125;</span><br><span class="hljs-comment">#因此可以使用&lt;a&gt;&lt;a/&gt;标签插入链接，以此类推至其他标签</span><br>hover_texts.append(hover_text)<br><br>fig = px.bar(... , hover_name = hover_text)<br></code></pre></td></tr></table></figure><h4 id="定制标记颜色"><a href="#定制标记颜色" class="headerlink" title="定制标记颜色"></a>定制标记颜色</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fig.update_traces(marker_color=<span class="hljs-string">&#x27;SteelBlue&#x27;</span>,marker_opacicy=<span class="hljs-number">0.6</span>)<br><span class="hljs-comment">#trace指的是图形上的数据，前缀为marker_的变量都会影响标记</span><br><span class="hljs-comment">#marker_opacicy控制不透明度，范围0.0~1.0，0.0为完全透明</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/27/Winsock2/"/>
    <url>/2024/10/27/Winsock2/</url>
    
    <content type="html"><![CDATA[<h1 id="Winsock2"><a href="#Winsock2" class="headerlink" title="Winsock2"></a>Winsock2</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="必要头文件与库"><a href="#必要头文件与库" class="headerlink" title="必要头文件与库"></a>必要头文件与库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winsock2.h&gt;</span><span class="hljs-comment">//包含windows.h</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib , <span class="hljs-string">&quot;Ws2_32&quot;</span>) <span class="hljs-comment">//导库</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">...<br>target_include_libraries(<span class="hljs-variable">$&#123;ProjectId&#125;</span> Ws2_32)<br></code></pre></td></tr></table></figure><h3 id="初始化Winsock2库"><a href="#初始化Winsock2库" class="headerlink" title="初始化Winsock2库"></a>初始化Winsock2库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib , <span class="hljs-string">&quot;Ws2_32&quot;</span>) </span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    WSADATA wsadata = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">//MAKEWORD(2,2) 指定最佳和最高winsock版本</span><br>    <span class="hljs-keyword">if</span> (WSAStartup(MAKEWORD(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),&amp;wsadata))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WSAStartup failed: %d\n&quot;</span>, iResult);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    ...<br>    WSACleanup();    <span class="hljs-comment">//释放Winsock资源</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">SOCKET socketListen = socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br><span class="hljs-comment">//AF_INET :IPv4地址格式 (AF_INET6 IPv6地址格式)</span><br><span class="hljs-comment">//SOCK_STREAM :流式套接字(面向连接，无差错，无重复)</span><br><span class="hljs-comment">//0 :自动指定与套接字类型匹配的协议</span><br><br><span class="hljs-keyword">if</span>(socketListen == INVALID_SOCKET)&#123;<br>    MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;套接字创建失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;socket error&quot;</span>),MB_OK);<br>    WSACleanup();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br>...<br>closesocket(socketListen); <span class="hljs-comment">//关闭套接字资源</span><br></code></pre></td></tr></table></figure><h3 id="将套接字与IP地址、端口号捆绑"><a href="#将套接字与IP地址、端口号捆绑" class="headerlink" title="将套接字与IP地址、端口号捆绑"></a>将套接字与IP地址、端口号捆绑</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sockAddr</span>;</span><br>sockAddr.sin_family = AF_INET;<br>sockAddr.sin_port = htons(POST);<br>sockAddr.sin_addr.S_un.S_addr = INADDR_ANY;<br><span class="hljs-comment">//INADDR_ANY :自动在本机所有IP地址上监听(每次连接都不知道它会用哪个地址，建议不用)</span><br><span class="hljs-comment">//inet_addr(&quot;127.0.0.1&quot;) 将IP从字符串转换成IPv4格式，127.0.0.1为本机地址</span><br><br><br><span class="hljs-keyword">if</span>(bind(socketListen, (SOCKADDR *) &amp;sockAddr, <span class="hljs-keyword">sizeof</span> (sockAddr)) == SOCKET_ERROR)&#123;<br>    MessageBoxA(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;套接字捆绑IP,端口失败&quot;</span>),TEXT(<span class="hljs-string">&quot;bind error&quot;</span>),MB_OK); <span class="hljs-comment">//MessageBoxA是个弹窗</span><br>    closesocket(socketListen)<br>    WSACleanup();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-comment">//可以使用getsockname(SOCKET s,sockaddr *name,int namelen)获取分配给套接字的地址</span><br></code></pre></td></tr></table></figure><h3 id="监听端口"><a href="#监听端口" class="headerlink" title="监听端口"></a>监听端口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//SOMAXCONN 将连接队列的最大长度设置为最大合理值</span><br><span class="hljs-keyword">if</span>(listen(socketListen,SOMAXCONN) == SOCKET_ERROR)&#123;<br>    MessageBoxA(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;监听端口失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Listen error&quot;</span>),MB_OK);<br>    closesocket(socketListen);<br>    WSACleanup();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接收连接请求，返回套接字句柄"><a href="#接收连接请求，返回套接字句柄" class="headerlink" title="接收连接请求，返回套接字句柄"></a>接收连接请求，返回套接字句柄</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sockAddrClient</span>;</span><br><span class="hljs-type">int</span> nAddrlen = <span class="hljs-keyword">sizeof</span> (sockAddrClient);<br><span class="hljs-keyword">while</span> (TRUE)&#123;<br>    SOCKET socketAccept = accept(socketListen,(SOCKADDR*)&amp;sockAddrClient,&amp;nAddrlen);<br>    <span class="hljs-keyword">if</span>(socketAccept == INVALID_SOCKET)&#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//发数据用send()</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">send</span> <span class="hljs-params">(</span><br><span class="hljs-params">    SOCKET s,<span class="hljs-comment">//已连接的套接字句柄 _In_(如果是服务器是socketAccept，客户端是socketClient)</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf,<span class="hljs-comment">//要发送数据的缓冲区指针_In_</span></span><br><span class="hljs-params"><span class="hljs-type">int</span> len,<span class="hljs-comment">//以字节为单位的缓冲区长度_In_</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> flags<span class="hljs-comment">//标志位，设置0就行_In_</span></span><br><span class="hljs-params">)</span><br><span class="hljs-comment">//收数据用recv()</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">recv</span> <span class="hljs-params">(</span><br><span class="hljs-params">SOCKET s,<span class="hljs-comment">// _In_</span></span><br><span class="hljs-params">    <span class="hljs-type">char</span> *buf,<span class="hljs-comment">//要接受数据的缓冲区指针_Out_</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> len,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> flag</span><br><span class="hljs-params">)</span>    <br></code></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化Winsock2</span><br><span class="hljs-comment">//创建套接字</span><br><span class="hljs-comment">//建立连接 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(</span><br><span class="hljs-params">SOCKET s,<span class="hljs-comment">//与服务器通信的套接字句柄(客户端就是socketClient)</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *name,<span class="hljs-comment">//包含服务器IP和端口号的sockaddr_in结构</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> namelen <span class="hljs-comment">//sockaddr_in结构的长度</span></span><br><span class="hljs-params">)</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/27/Qt%E6%8E%A7%E4%BB%B6/"/>
    <url>/2024/10/27/Qt%E6%8E%A7%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><h3 id="1-垂直布局（Vertical-Layout）"><a href="#1-垂直布局（Vertical-Layout）" class="headerlink" title="1. 垂直布局（Vertical Layout）"></a>1. 垂直布局（Vertical Layout）</h3><ul><li><strong>功能</strong>：垂直布局将控件按垂直方向排列，每个控件占据一行。当窗口大小改变时，控件会保持垂直排列，并根据需要调整大小。</li><li><strong>应用场景</strong>：适用于需要将多个控件垂直堆叠的场景，如设置对话框中的选项按钮。</li></ul><h3 id="2-水平布局（Horizontal-Layout）"><a href="#2-水平布局（Horizontal-Layout）" class="headerlink" title="2. 水平布局（Horizontal Layout）"></a>2. 水平布局（Horizontal Layout）</h3><ul><li><strong>功能</strong>：水平布局将控件按水平方向排列，每个控件占据一列。当窗口大小改变时，控件会保持水平排列，并根据需要调整大小。</li><li><strong>应用场景</strong>：适用于需要将多个控件水平排列的场景，如工具栏中的按钮。</li></ul><h3 id="3-网格布局（Grid-Layout）"><a href="#3-网格布局（Grid-Layout）" class="headerlink" title="3. 网格布局（Grid Layout）"></a>3. 网格布局（Grid Layout）</h3><ul><li><strong>功能</strong>：网格布局将控件放置在一个网格中，每个控件占据一个或多个单元格。当窗口大小改变时，所有单元格的大小会等比例调整，以保持控件之间的相对位置和大小关系。</li><li><strong>应用场景</strong>：适用于需要复杂布局的场景，如表单输入界面，其中控件需要按照特定的行列关系排列。</li></ul><h3 id="4-表单布局（Form-Layout）"><a href="#4-表单布局（Form-Layout）" class="headerlink" title="4. 表单布局（Form Layout）"></a>4. 表单布局（Form Layout）</h3><ul><li><strong>功能</strong>：表单布局类似于网格布局，但它通常用于创建表单界面。在表单布局中，标签（Label）和相应的输入控件（如LineEdit、SpinBox等）会成对出现，标签通常位于输入控件的左侧或上方。</li><li><strong>应用场景</strong>：适用于需要创建数据输入表单的场景，如用户注册界面。</li></ul><h3 id="布局控件的共同特点和使用注意事项："><a href="#布局控件的共同特点和使用注意事项：" class="headerlink" title="布局控件的共同特点和使用注意事项："></a>布局控件的共同特点和使用注意事项：</h3><ul><li><strong>自动管理控件大小</strong>：布局控件会根据窗口大小自动调整内部控件的大小和位置，无需手动设置。</li><li><strong>嵌套使用</strong>：布局控件可以嵌套使用，以创建更复杂的布局结构。例如，可以在水平布局中嵌套垂直布局，或在网格布局中嵌套其他布局控件。</li><li><strong>边距和间距</strong>：在布局控件中，可以设置边距（Margin）和间距（Spacing）来调整控件与布局边界以及控件之间的空间距离。</li><li><strong>伸缩性</strong>：某些布局控件（如网格布局和表单布局）支持伸缩性设置，允许用户指定在窗口大小改变时哪些控件应该优先调整大小。</li></ul><h3 id="使用布局控件的建议："><a href="#使用布局控件的建议：" class="headerlink" title="使用布局控件的建议："></a>使用布局控件的建议：</h3><ul><li><strong>尽早使用布局</strong>：在设计GUI界面时，应尽早使用布局控件来规划控件的排列方式，以避免在后期调整界面布局时出现混乱。</li><li><strong>合理利用嵌套布局</strong>：通过嵌套使用不同的布局控件，可以创建出既美观又实用的GUI界面。但需要注意的是，过度嵌套可能会导致布局变得复杂且难以维护。</li><li><strong>注意控件的默认大小和策略</strong>：某些控件具有默认的大小和伸缩策略，这些设置可能会影响布局控件的效果。因此，在设计界面时需要注意控件的这些属性并根据需要进行调整。</li></ul><h2 id="Spacer"><a href="#Spacer" class="headerlink" title="Spacer"></a>Spacer</h2><h3 id="一、Spacer控件的类型"><a href="#一、Spacer控件的类型" class="headerlink" title="一、Spacer控件的类型"></a>一、Spacer控件的类型</h3><p>Qt Designer提供了两种主要类型的Spacer控件，虽然在实际使用中可能通过不同的方式实现（如QSpacerItem和QSpacerWidget），但在Qt Designer的界面中，用户主要关注的是它们的功能和效果：</p><ol><li><p><strong>横向Spacer</strong>：</p><ul><li>功能：用于在水平方向上占据空间，调整控件之间的水平间距。</li><li>应用场景：当需要在水平布局中增加控件之间的水平间距时，可以使用横向Spacer。</li></ul></li><li><p><strong>纵向Spacer</strong>：</p><ul><li>功能：用于在垂直方向上占据空间，调整控件之间的垂直间距。</li><li>应用场景：当需要在垂直布局中增加控件之间的垂直间距时，可以使用纵向Spacer。</li></ul></li></ol><p>需要注意的是，虽然Qt Designer的界面可能不直接区分“横向Spacer”和“纵向Spacer”作为独立的控件类型，但用户可以通过在水平布局中添加Spacer来实现横向间距的调整，在垂直布局中添加Spacer来实现纵向间距的调整。</p><h3 id="二、Spacer控件的属性"><a href="#二、Spacer控件的属性" class="headerlink" title="二、Spacer控件的属性"></a>二、Spacer控件的属性</h3><p>Spacer控件在Qt Designer中可能不直接暴露所有底层属性（如QSpacerItem的sizeHint和stretch属性），但用户可以通过布局管理器间接控制Spacer的行为。然而，了解Spacer控件背后的一些常见属性对于深入理解其工作原理是有帮助的：</p><ul><li><strong>sizeHint</strong>：Spacer控件建议的大小。这通常是一个最小值，布局管理器可能会根据需要进行调整。</li><li><strong>stretch</strong>：Spacer控件的伸缩因子。它决定了在布局调整大小时，Spacer控件相对于其他控件应该占据多少额外空间。stretch值较大的Spacer控件会占据更多的额外空间。</li></ul><p>在Qt Designer中，用户可能无法直接设置这些属性，但可以通过调整布局和Spacer控件的位置和大小来间接影响它们。</p><h3 id="三、Spacer控件的使用"><a href="#三、Spacer控件的使用" class="headerlink" title="三、Spacer控件的使用"></a>三、Spacer控件的使用</h3><p>在Qt Designer中使用Spacer控件非常直观：</p><ol><li><p><strong>添加Spacer</strong>：</p><ul><li>打开Qt Designer并加载或创建一个UI文件。</li><li>在工具箱中找到Spacer控件（有时可能需要先选择一个布局容器，因为Spacer控件不是独立的控件，而是布局的一部分）。</li><li>将Spacer控件拖拽到布局中的适当位置。</li></ul></li><li><p><strong>调整Spacer</strong>：</p><ul><li>选中Spacer控件后，您可能会看到它的边缘出现调整手柄（这取决于Qt Designer的版本和设置）。</li><li>通过拖动调整手柄，您可以改变Spacer控件的大小。然而，请注意，对于Spacer控件来说，“大小”实际上是一个相对概念，它更多地影响的是布局中其他控件之间的间距。</li></ul></li><li><p><strong>观察效果</strong>：</p><ul><li>在调整Spacer控件后，观察布局中其他控件的位置和间距是否如您所期望的那样发生了变化。</li></ul></li></ol><h3 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h3><ul><li><strong>Spacer控件的实际效果取决于布局管理器和其他控件的属性</strong>。因此，在调整Spacer控件时，请务必考虑整个布局的情况。</li><li><strong>避免过度使用Spacer控件</strong>。虽然Spacer控件是调整布局间距的有用工具，但过度使用可能会使布局变得复杂且难以维护。在可能的情况下，尝试使用布局管理器的默认间距和边距属性来简化布局设计。</li></ul><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><p>在Qt Designer中，Button控件是一组用于与用户交互的按钮类控件，它们提供了不同的功能和外观选项。以下是对所有常见Button控件的详细讲解：</p><h3 id="1-Push-Button（常规按钮）"><a href="#1-Push-Button（常规按钮）" class="headerlink" title="1. Push Button（常规按钮）"></a>1. Push Button（常规按钮）</h3><ul><li><strong>功能</strong>：Push Button是最常见的按钮类型，用于响应用户的点击操作。点击后会触发clicked信号。</li><li><strong>外观定制</strong>：可以通过设置按钮的文本、图标等属性来定制其外观。同时，支持通过样式表进一步定制按钮的样式。</li><li><strong>使用场景</strong>：适用于大多数需要用户点击以执行操作的场景，如提交表单、打开新窗口等。</li></ul><h3 id="2-Tool-Button（工具按钮）"><a href="#2-Tool-Button（工具按钮）" class="headerlink" title="2. Tool Button（工具按钮）"></a>2. Tool Button（工具按钮）</h3><ul><li><strong>功能</strong>：通常用于创建工具栏按钮，可以显示图标、文本或者同时显示两者。工具按钮还可以包含一个菜单项，当用户点击时弹出菜单。</li><li><strong>外观定制</strong>：除了文本和图标外，还可以设置按钮的弹出模式（即时弹出、延迟弹出等）和样式。</li><li><strong>使用场景</strong>：适用于工具栏中的快速访问按钮，如保存、打开、撤销等操作。</li></ul><h3 id="3-Radio-Button（单选按钮）"><a href="#3-Radio-Button（单选按钮）" class="headerlink" title="3. Radio Button（单选按钮）"></a>3. Radio Button（单选按钮）</h3><ul><li><strong>功能</strong>：用于在一组选项中选择一个选项。当选择某个单选按钮时，其他单选按钮将被自动取消选择。</li><li><strong>使用注意事项</strong>：单选按钮通常需要放在RadioGroup内以实现单选功能。</li><li><strong>使用场景</strong>：适用于需要从一组互斥选项中选择一个的场景，如性别选择、语言选择等。</li></ul><h3 id="4-Check-Box（复选框）"><a href="#4-Check-Box（复选框）" class="headerlink" title="4. Check Box（复选框）"></a>4. Check Box（复选框）</h3><ul><li><strong>功能</strong>：用于可选的选项，可以选择多个。与单选按钮不同，复选框允许用户同时选择多个选项。</li><li><strong>使用场景</strong>：适用于需要从多个可选项中选择一个或多个的场景，如同意隐私政策、订阅新闻等。</li><li><strong>特有属性</strong>：复选框还可以设置为三态（未选中、选中、半选中），但这需要特别配置。</li></ul><h3 id="5-Command-Link-Button（命令链接按钮）"><a href="#5-Command-Link-Button（命令链接按钮）" class="headerlink" title="5. Command Link Button（命令链接按钮）"></a>5. Command Link Button（命令链接按钮）</h3><ul><li><strong>功能</strong>：这是一种类似于QPushButton的按钮类型，但具有更多的样式和功能。它可以显示文本、图标以及访问键信息，并支持拖拽操作。</li><li><strong>外观定制</strong>：提供了更多的样式选项，如高亮、悬停等状态样式。</li><li><strong>使用场景</strong>：常用于向导和对话框中，提供类似链接的按钮样式，以增加用户的交互体验。</li></ul><h3 id="6-Dialog-Button-Box（对话框按钮盒）"><a href="#6-Dialog-Button-Box（对话框按钮盒）" class="headerlink" title="6. Dialog Button Box（对话框按钮盒）"></a>6. Dialog Button Box（对话框按钮盒）</h3><ul><li><strong>功能</strong>：这是一种特殊的按钮容器，用于放置对话框中的标准按钮，如“OK”、“Cancel”、“Yes”、“No”等。它提供了统一的外观和行为标准，方便用户理解和使用。</li><li><strong>使用方式</strong>：可以自定义按钮布局和样式，也可以直接使用系统默认按钮。</li><li><strong>使用场景</strong>：适用于所有需要标准对话框按钮布局的场景，如确认对话框、设置对话框等。</li></ul><h3 id="共性属性"><a href="#共性属性" class="headerlink" title="共性属性"></a>共性属性</h3><p>除了上述特定于每种Button控件的属性外，它们还共享一些共性属性，这些属性通常通过QAbstractButton类提供：</p><ul><li><strong>text</strong>：按钮上显示的文本。</li><li><strong>icon</strong>：按钮上显示的图标。</li><li><strong>iconSize</strong>：图标的大小。</li><li><strong>shortcut</strong>：与按钮关联的快捷键。</li><li><strong>checkable</strong>：按钮是否可以被选中（对于非单选&#x2F;复选框按钮）。</li><li><strong>checked</strong>：按钮是否被选中的状态。</li><li><strong>autoRepeat</strong>、<strong>autoRepeatDelay</strong>、<strong>autoRepeatInterval</strong>：控制按钮按下事件是否重复、重复的频次等。</li><li><strong>autoExclusive</strong>：是否启用按钮的自动排他特性（对于非单选按钮）。</li></ul><p>这些共性属性使得开发者能够灵活地定制Button控件的行为和外观，以满足不同应用程序的需求。同时，Qt Designer提供的拖放式设计方式大大简化了界面开发的过程，提高了开发效率。</p><h2 id="item-view"><a href="#item-view" class="headerlink" title="item view"></a>item view</h2><p>在Qt Designer中，Item View控件是基于模型&#x2F;视图（Model&#x2F;View）架构的一组控件，用于展示和操作数据。这些控件通过分离数据的存储（模型）和数据的展示（视图），提供了灵活且高效的数据展示方式。以下是几种常见的Item View控件的详细讲解：</p><h3 id="1-List-View（列表视图）"><a href="#1-List-View（列表视图）" class="headerlink" title="1. List View（列表视图）"></a>1. List View（列表视图）</h3><ul><li><strong>功能</strong>：用于展示列表形式的数据。可以定制列表项的显示方式，如文本、图标等，并支持单选或多选。</li><li><strong>数据模型</strong>：List View本身不存储数据，而是通过一个数据模型（如QStringListModel、QStandardItemModel等）来获取数据。</li><li><strong>特点</strong>：提供垂直滚动条，支持拖拽操作，可以设置选择模式、编辑触发器等。</li><li><strong>使用场景</strong>：适用于需要展示一系列可选项的场景，如文件列表、搜索结果等。</li></ul><h3 id="2-Tree-View（树形视图）"><a href="#2-Tree-View（树形视图）" class="headerlink" title="2. Tree View（树形视图）"></a>2. Tree View（树形视图）</h3><ul><li><strong>功能</strong>：用于展示树形结构的数据，如文件系统、组织结构图等。支持节点的展开和折叠，以及节点的拖拽操作。</li><li><strong>数据模型</strong>：与List View类似，Tree View也通过数据模型来获取数据，常用的数据模型包括QAbstractItemModel、QStandardItemModel等。</li><li><strong>特点</strong>：提供垂直滚动条，可以定制节点的显示方式，支持多列展示（通过QTreeView配合委托实现）。</li><li><strong>使用场景</strong>：适用于需要展示层次结构数据的场景。</li></ul><h3 id="3-Table-View（表格视图）"><a href="#3-Table-View（表格视图）" class="headerlink" title="3. Table View（表格视图）"></a>3. Table View（表格视图）</h3><ul><li><strong>功能</strong>：用于展示二维表格数据，如电子表格、数据库表格等。支持行和列的插入、删除、移动，以及数据的排序和过滤。</li><li><strong>数据模型</strong>：Table View同样需要一个数据模型来提供数据，常用的数据模型包括QAbstractTableModel、QStandardItemModel等。</li><li><strong>特点</strong>：提供水平和垂直滚动条，可以调整列宽和行高，支持多选、排序、过滤等功能。</li><li><strong>使用场景</strong>：适用于需要展示和编辑二维数据的场景。</li></ul><h3 id="4-Column-View（列视图）"><a href="#4-Column-View（列视图）" class="headerlink" title="4. Column View（列视图）"></a>4. Column View（列视图）</h3><ul><li><strong>功能</strong>：Column View是一种特殊的列表视图，它以列为单位展示数据，每列可以看作是一个独立的列表视图。</li><li><strong>特点</strong>：这种展示方式对于展示具有层次结构但层级不多的数据特别有用，因为它允许用户通过横向滚动来查看不同层级的数据。</li><li><strong>使用场景</strong>：适用于需要展示有限层级的树形结构数据的场景。</li></ul><h3 id="5-Undo-View（撤销命令视图）"><a href="#5-Undo-View（撤销命令视图）" class="headerlink" title="5. Undo View（撤销命令视图）"></a>5. Undo View（撤销命令视图）</h3><ul><li><strong>功能</strong>：Undo View提供了一个用户界面来展示和操作QUndoStack中的命令。用户可以从列表中选择并撤销或重做特定的命令。</li><li><strong>特点</strong>：通常显示为一个列表，与List View类似，但专门用于撤销&#x2F;重做操作的管理。</li><li><strong>使用场景</strong>：在需要支持撤销&#x2F;重做功能的应用程序中非常有用，如文本编辑器、图形编辑器等。</li></ul><h3 id="共性特点"><a href="#共性特点" class="headerlink" title="共性特点"></a>共性特点</h3><ul><li><strong>模型&#x2F;视图分离</strong>：所有Item View控件都遵循模型&#x2F;视图架构，使得数据的存储和展示可以独立进行，提高了数据管理的灵活性和效率。</li><li><strong>丰富的接口和属性</strong>：这些控件提供了丰富的接口和属性，允许开发者定制外观、行为和数据交互方式。</li><li><strong>易于集成</strong>：在Qt Designer中，开发者可以通过拖拽的方式将这些视图控件添加到界面中，并通过属性编辑器设置相关属性，使得界面开发更加直观和高效。</li></ul><p>总的来说，Qt Designer中的Item View控件为开发者提供了强大的数据展示和操作功能，通过灵活使用这些控件，可以构建出丰富多样的用户界面。</p><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><p>在Qt Designer中，Container控件（容器控件）主要用于对界面上的其他控件进行分组、布局和管理，以提高界面的组织性和美观性。以下是对几种常见Container控件的详细讲解：</p><h3 id="1-Group-Box（分组框）"><a href="#1-Group-Box（分组框）" class="headerlink" title="1. Group Box（分组框）"></a>1. Group Box（分组框）</h3><ul><li><strong>功能</strong>：将一组相关的控件组织在一起，并在外部提供一个边框和标题栏，用于标识这组控件的用途或类别。</li><li><strong>特点</strong>：分组框内部通常需要使用布局管理器（如QHBoxLayout、QVBoxLayout等）来安排控件的位置和大小。分组框本身也可以响应点击事件，但主要作用是作为控件的容器。</li><li><strong>使用场景</strong>：适用于需要将一组控件作为一个整体进行展示和操作的场景，如设置选项、表单输入等。</li></ul><h3 id="2-Scroll-Area（滚动区域）"><a href="#2-Scroll-Area（滚动区域）" class="headerlink" title="2. Scroll Area（滚动区域）"></a>2. Scroll Area（滚动区域）</h3><ul><li><strong>功能</strong>：提供一个可滚动的视图区域，用于在有限的显示空间内展示大量内容或控件。</li><li><strong>特点</strong>：当滚动区域的内容超出其可视范围时，会自动显示滚动条，允许用户通过滚动来查看完整内容。滚动区域可以包含任何类型的控件或布局。</li><li><strong>使用场景</strong>：适用于需要展示大量数据或控件，但显示空间有限的场景，如长文本编辑器、图片查看器等。</li></ul><h3 id="3-Tab-Widget（标签页部件）"><a href="#3-Tab-Widget（标签页部件）" class="headerlink" title="3. Tab Widget（标签页部件）"></a>3. Tab Widget（标签页部件）</h3><ul><li><strong>功能</strong>：允许在同一个区域内通过标签页的形式切换不同的界面或内容。</li><li><strong>特点</strong>：每个标签页都对应一个独立的界面或内容区域，用户可以通过点击标签页来切换显示的内容。标签页部件提供了丰富的接口来管理标签页，如添加、删除、重命名等。</li><li><strong>使用场景</strong>：适用于需要将多个相关但独立的界面组织在一起，并通过标签页进行切换的场景，如浏览器的多个标签页、软件的多功能界面等。</li></ul><h3 id="4-Stacked-Widget（堆叠控件）"><a href="#4-Stacked-Widget（堆叠控件）" class="headerlink" title="4. Stacked Widget（堆叠控件）"></a>4. Stacked Widget（堆叠控件）</h3><ul><li><strong>功能</strong>：以堆叠的方式组织多个控件或界面，但一次只显示一个控件或界面。</li><li><strong>特点</strong>：通过编程方式或与其他控件（如列表框）配合，可以实现控件或界面之间的切换。堆叠控件不提供直接的切换界面，需要通过代码或信号与槽机制来实现。</li><li><strong>使用场景</strong>：适用于需要根据用户操作或条件动态切换显示不同控件或界面的场景，如向导式界面、设置选项卡等。</li></ul><h3 id="5-Tool-Box（工具箱）"><a href="#5-Tool-Box（工具箱）" class="headerlink" title="5. Tool Box（工具箱）"></a>5. Tool Box（工具箱）</h3><ul><li><strong>功能</strong>：提供一个多页面的工具箱，每个页面可以包含多个控件或布局。</li><li><strong>特点</strong>：类似于标签页部件，但工具箱的页面通常通过按钮或标题栏来切换，且页面之间的切换更加紧凑和直观。工具箱也支持拖拽操作，允许用户重新排列页面顺序。</li><li><strong>使用场景</strong>：适用于需要将多个相关页面组织在一起，并通过按钮或标题栏进行切换的场景，如软件的工具箱、设置选项分组等。</li></ul><h3 id="6-Frame（框架）"><a href="#6-Frame（框架）" class="headerlink" title="6. Frame（框架）"></a>6. Frame（框架）</h3><ul><li><strong>功能</strong>：作为其他控件的容器，用于对控件进行分组或装饰。</li><li><strong>特点</strong>：框架本身不提供滚动条或标签页等功能，但可以通过设置边框样式、阴影等属性来美化界面。框架内部同样需要使用布局管理器来安排控件的位置和大小。</li><li><strong>使用场景</strong>：适用于需要对一组控件进行简单分组或装饰的场景，如表单中的字段分组、界面中的装饰性边框等。</li></ul><h3 id="共性特点-1"><a href="#共性特点-1" class="headerlink" title="共性特点"></a>共性特点</h3><ul><li><strong>容器作用</strong>：所有Container控件都作为其他控件的容器，用于组织和管理界面元素。</li><li><strong>布局管理</strong>：内部通常需要使用布局管理器来安排控件的位置和大小，以确保界面的整洁和一致性。</li><li><strong>灵活定制</strong>：大多数Container控件都提供了丰富的属性和接口，允许开发者根据需要进行定制和扩展。</li></ul><p>通过合理使用这些Container控件，开发者可以构建出结构清晰、美观易用的用户界面。</p><h2 id="Input-Widget"><a href="#Input-Widget" class="headerlink" title="Input Widget"></a>Input Widget</h2><p>在Qt Designer中，Input Widgets（输入控件）是一组用于接收用户输入的界面元素。这些控件允许用户通过键盘、鼠标或其他输入设备输入文本、数字、日期时间等信息。以下是对Qt中常见Input Widgets控件的详细讲解：</p><h3 id="1-QLineEdit（单行文本编辑框）"><a href="#1-QLineEdit（单行文本编辑框）" class="headerlink" title="1. QLineEdit（单行文本编辑框）"></a>1. QLineEdit（单行文本编辑框）</h3><ul><li><strong>功能</strong>：用于单行文本输入，如用户名、密码等。</li><li><strong>常用方法</strong>：<ul><li><code>setText(const QString &amp;text)</code>：设置文本框内容。</li><li><code>text() const</code>：返回文本框内容。</li><li><code>clear()</code>：清除文本框内容。</li></ul></li><li><strong>信号</strong>：<ul><li><code>textChanged(const QString &amp;text)</code>：当文本框内容发生变化时发射。</li><li><code>editingFinished()</code>：当编辑完成（如按下回车键）时发射。</li></ul></li><li><strong>使用场景</strong>：适用于需要单行文本输入的场景。</li></ul><h3 id="2-QTextEdit（多行文本编辑框）"><a href="#2-QTextEdit（多行文本编辑框）" class="headerlink" title="2. QTextEdit（多行文本编辑框）"></a>2. QTextEdit（多行文本编辑框）</h3><ul><li><strong>功能</strong>：用于多行文本输入，支持富文本格式（HTML）。</li><li><strong>常用方法</strong>：<ul><li><code>toPlainText()</code>：返回文本框内的纯文本内容。</li><li><code>setPlainText(const QString &amp;text)</code>：设置文本框内的纯文本内容。</li><li><code>toHtml()</code>：返回文本框内的HTML内容。</li><li><code>setHtml(const QString &amp;text)</code>：设置文本框内的HTML内容。</li></ul></li><li><strong>信号</strong>：<ul><li><code>textChanged()</code>：当文本内容发生变化时发射。</li><li><code>cursorPositionChanged()</code>：当光标位置发生变化时发射。</li></ul></li><li><strong>使用场景</strong>：适用于需要输入或显示多行文本的场景，如邮件正文、聊天窗口等。</li></ul><h3 id="3-QPlainTextEdit（纯文本多行编辑框）"><a href="#3-QPlainTextEdit（纯文本多行编辑框）" class="headerlink" title="3. QPlainTextEdit（纯文本多行编辑框）"></a>3. QPlainTextEdit（纯文本多行编辑框）</h3><ul><li><strong>功能</strong>：与QTextEdit类似，但专门用于纯文本编辑，不支持富文本格式。</li><li><strong>常用方法</strong>：<ul><li><code>toPlainText()</code>：返回文本框内的纯文本内容。</li><li><code>appendPlainText(const QString &amp;text)</code>：在文本末尾追加纯文本内容。</li><li><code>insertPlainText(const QString &amp;text)</code>：在光标位置插入纯文本内容。</li></ul></li><li><strong>信号</strong>：<ul><li><code>textChanged()</code>：当文本内容发生变化时发射。</li><li><code>cursorPositionChanged()</code>：当光标位置发生变化时发射。</li></ul></li><li><strong>使用场景</strong>：适用于需要编辑纯文本的场景，如代码编辑器、文本文件编辑器等。</li></ul><h3 id="4-QSpinBox（整数调节按钮）"><a href="#4-QSpinBox（整数调节按钮）" class="headerlink" title="4. QSpinBox（整数调节按钮）"></a>4. QSpinBox（整数调节按钮）</h3><ul><li><strong>功能</strong>：允许用户通过点击上下箭头或输入数字来选择一个整数值。</li><li><strong>常用属性</strong>：<ul><li><code>minimum</code>：最小值。</li><li><code>maximum</code>：最大值。</li><li><code>singleStep</code>：每次点击箭头改变的值。</li><li><code>value</code>：当前值。</li></ul></li><li><strong>常用方法</strong>：<ul><li><code>setValue(int val)</code>：设置当前值。</li><li><code>value()</code>：获取当前值。</li></ul></li><li><strong>信号</strong>：<ul><li><code>valueChanged(int i)</code>：当值发生变化时发射。</li></ul></li><li><strong>使用场景</strong>：适用于需要用户输入整数值的场景，如年龄、数量等。</li></ul><h3 id="5-QDoubleSpinBox（浮点数调节按钮）"><a href="#5-QDoubleSpinBox（浮点数调节按钮）" class="headerlink" title="5. QDoubleSpinBox（浮点数调节按钮）"></a>5. QDoubleSpinBox（浮点数调节按钮）</h3><ul><li><strong>功能</strong>：与QSpinBox类似，但允许用户输入浮点数。</li><li><strong>特有属性</strong>：<ul><li><code>decimals</code>：小数点后的位数。</li></ul></li><li><strong>其他属性与方法</strong>：与QSpinBox相似。</li><li><strong>使用场景</strong>：适用于需要用户输入浮点数值的场景，如价格、百分比等。</li></ul><h3 id="6-QComboBox（下拉列表框）"><a href="#6-QComboBox（下拉列表框）" class="headerlink" title="6. QComboBox（下拉列表框）"></a>6. QComboBox（下拉列表框）</h3><ul><li><strong>功能</strong>：提供一个下拉列表供用户选择，节省屏幕空间。</li><li><strong>常用方法</strong>：<ul><li><code>addItem(const QString &amp;text, const QVariant &amp;userData = QVariant())</code>：添加单个选项。</li><li><code>addItems(const QStringList &amp;texts)</code>：添加多个选项。</li><li><code>currentIndex()</code>：获取当前选中项的索引。</li><li><code>currentText()</code>：获取当前选中项的文本。</li></ul></li><li><strong>信号</strong>：<ul><li><code>currentIndexChanged(int index)</code>：当选中项发生变化时发射，参数为新的索引值。</li><li><code>currentIndexChanged(const QString &amp;text)</code>：当选中项发生变化时发射，参数为新的文本值。</li></ul></li><li><strong>使用场景</strong>：适用于需要从预定义选项中选择一个的场景，如性别、国家等。</li></ul><h3 id="7-QFontComboBox（字体组合框）"><a href="#7-QFontComboBox（字体组合框）" class="headerlink" title="7. QFontComboBox（字体组合框）"></a>7. QFontComboBox（字体组合框）</h3><ul><li><strong>功能</strong>：允许用户从下拉列表中选择字体。</li><li><strong>常用方法</strong>：<ul><li><code>currentFont()</code>：获取当前选中的字体。</li><li><code>setFontFilters(const QFontFilters &amp;filters)</code>：设置字体过滤器，以限制可选的字体。</li></ul></li><li><strong>信号</strong>：<ul><li><code>currentFontChanged(const QFont &amp;f)</code>：当选中字体发生变化时发射。</li></ul></li><li><strong>使用场景</strong>：适用于需要用户选择字体的场景，如文本编辑器、图形设计工具等。</li></ul><h3 id="8-QDateTimeEdit、QDateEdit、QTimeEdit（日期时间、日期、时间编辑框）"><a href="#8-QDateTimeEdit、QDateEdit、QTimeEdit（日期时间、日期、时间编辑框）" class="headerlink" title="8. QDateTimeEdit、QDateEdit、QTimeEdit（日期时间、日期、时间编辑框）"></a>8. QDateTimeEdit、QDateEdit、QTimeEdit（日期时间、日期、时间编辑框）</h3><ul><li><strong>功能</strong>：分别用于编辑日期时间、日期和时间。</li><li><strong>常用方法</strong>：<ul><li><code>setDate(const QDate &amp;date)</code>：设置日期。</li><li><code>setTime(const QTime &amp;time)</code>：设置时间。</li><li><code>setDateTime(const QDateTime &amp;dateTime)</code>：设置日期和时间。</li><li><code>date()</code>、<code>time()</code>、<code>dateTime()</code>：分别获取当前日期、时间和日期时间。</li></ul></li><li><strong>信号</strong>：<ul><li><code>dateChanged(const QDate &amp;date)</code>：当日期发生变化时发射。</li><li><code>timeChanged(const QTime &amp;time)</code>：当时间发生变化时发射。</li><li><code>dateTimeChanged(const QDateTime &amp;dateTime)</code>：当日期时间发生变化时发射。</li></ul></li><li><strong>使用场景</strong>：适用于需要用户输入日期、时间或日期时间的场景，如日历、任务管理器等。</li></ul><p>这些Input Widgets控件为Qt应用程序提供了丰富的用户输入方式，开发者可以根据具体需求选择合适的控件来构建用户界面。</p><h2 id="display-widget"><a href="#display-widget" class="headerlink" title="display widget"></a>display widget</h2><p>在Qt框架中，Display Widgets（显示控件）是用于展示和呈现数据给用户查看的界面元素。这些控件不直接接收用户输入，而是将程序内部的数据以图形化的方式展示出来。以下是对Qt中常见Display Widgets控件的详细讲解：</p><h3 id="1-QLabel（标签）"><a href="#1-QLabel（标签）" class="headerlink" title="1. QLabel（标签）"></a>1. QLabel（标签）</h3><ul><li><p><strong>功能</strong>：用于显示文本、图片或动画。QLabel是Qt中最基本也是最常用的显示控件之一。</p></li><li><p>常用方法</p><p>：</p><ul><li><code>setText(const QString &amp;text)</code>：设置显示的文本内容。</li><li><code>setPixmap(const QPixmap &amp;pixmap)</code>：设置显示的图片。</li><li><code>setAlignment(Qt::Alignment flag)</code>：设置文本或图片的对齐方式。</li></ul></li><li><p><strong>信号</strong>：QLabel本身不直接提供用于内容变化的信号，但可以通过与其他控件的交互来间接触发信号。</p></li><li><p><strong>使用场景</strong>：适用于需要显示静态文本、图片或简单动画的场景，如标题栏、提示信息等。</p></li></ul><h3 id="2-QTextBrowser（文本浏览器）"><a href="#2-QTextBrowser（文本浏览器）" class="headerlink" title="2. QTextBrowser（文本浏览器）"></a>2. QTextBrowser（文本浏览器）</h3><ul><li><p><strong>功能</strong>：用于显示和编辑富文本内容，支持HTML格式。</p></li><li><p>常用方法</p><p>：</p><ul><li><code>setText(const QString &amp;text)</code>：设置显示的文本内容。</li><li><code>setHtml(const QString &amp;html)</code>：设置显示的HTML内容。</li><li><code>anchorClicked(const QUrl &amp;url)</code>：当用户点击HTML中的链接时发射的信号。</li></ul></li><li><p><strong>使用场景</strong>：适用于需要显示复杂文本格式（如带有超链接、图片、格式化的文本等）的场景，如帮助文档、新闻阅读器等。</p></li></ul><h3 id="3-QGraphicsView（图形视图）"><a href="#3-QGraphicsView（图形视图）" class="headerlink" title="3. QGraphicsView（图形视图）"></a>3. QGraphicsView（图形视图）</h3><ul><li><p><strong>功能</strong>：用于显示和管理QGraphicsScene（场景）中的图形项（如线条、形状、图像等）。</p></li><li><p><strong>特点</strong>：QGraphicsView和QGraphicsScene一起构成了Qt中强大的二维图形框架，支持复杂的图形交互和渲染。</p></li><li><p>常用方法</p><p>：</p><ul><li><code>setScene(QGraphicsScene *scene)</code>：设置要显示的场景。</li><li><code>scene()</code>：获取当前显示的场景。</li></ul></li><li><p><strong>使用场景</strong>：适用于需要展示复杂图形界面、进行图形交互（如拖拽、缩放、旋转等）的场景，如绘图软件、游戏界面等。</p></li></ul><h3 id="4-QCalendarWidget（日历控件）"><a href="#4-QCalendarWidget（日历控件）" class="headerlink" title="4. QCalendarWidget（日历控件）"></a>4. QCalendarWidget（日历控件）</h3><ul><li><p><strong>功能</strong>：提供一个日历视图，允许用户选择日期。</p></li><li><p>常用方法</p><p>：</p><ul><li><code>setSelectedDate(const QDate &amp;date)</code>：设置选中的日期。</li><li><code>selectedDate()</code>：获取当前选中的日期。</li></ul></li><li><p>信号</p><p>：</p><ul><li><code>selectionChanged()</code>：当选中日期发生变化时发射。</li></ul></li><li><p><strong>使用场景</strong>：适用于需要用户选择日期的场景，如日程安排、事件提醒等。</p></li></ul><h3 id="5-QProgressBar（进度条）"><a href="#5-QProgressBar（进度条）" class="headerlink" title="5. QProgressBar（进度条）"></a>5. QProgressBar（进度条）</h3><ul><li><p><strong>功能</strong>：用于显示任务的进度。</p></li><li><p>常用方法</p><p>：</p><ul><li><code>setValue(int value)</code>：设置进度条的值。</li><li><code>value()</code>：获取进度条当前的值。</li></ul></li><li><p>信号</p><p>：</p><ul><li><code>valueChanged(int value)</code>：当进度条的值发生变化时发射。</li></ul></li><li><p><strong>使用场景</strong>：适用于需要展示任务进度的场景，如下载进度、加载进度等。</p></li></ul><h3 id="6-QLCDNumber（液晶数字显示）"><a href="#6-QLCDNumber（液晶数字显示）" class="headerlink" title="6. QLCDNumber（液晶数字显示）"></a>6. QLCDNumber（液晶数字显示）</h3><ul><li><p><strong>功能</strong>：模仿液晶显示屏的数字显示方式，用于显示数字。</p></li><li><p>常用方法</p><p>：</p><ul><li><code>display(const QString &amp;text)</code>：设置显示的文本（数字）。</li><li><code>setNum(int num)</code>：直接设置要显示的整数。</li></ul></li><li><p><strong>使用场景</strong>：适用于需要以特殊方式（如液晶显示风格）展示数字的场景，如计时器、温度计等模拟界面。</p></li></ul><h3 id="7-其他Display-Widgets"><a href="#7-其他Display-Widgets" class="headerlink" title="7. 其他Display Widgets"></a>7. 其他Display Widgets</h3><p>Qt还提供了其他一些Display Widgets控件，如QHorizontalLine（水平线）、QVerticalLine（垂直线）、QOpenGLWidget（OpenGL图形渲染控件）、QQuickWidget（QML嵌入控件）等。这些控件各有特色，适用于不同的显示需求。例如，水平线和垂直线用于分隔界面元素；QOpenGLWidget用于集成OpenGL渲染管线到Qt应用程序中；QQuickWidget允许将基于QML的用户界面组件集成到传统的Qt Widgets应用中。</p><p>综上所述，Qt中的Display Widgets控件为开发者提供了丰富的界面展示手段，可以根据具体需求选择合适的控件来构建用户友好的界面。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/27/pygame/"/>
    <url>/2024/10/27/pygame/</url>
    
    <content type="html"><![CDATA[<h1 id="Pygame"><a href="#Pygame" class="headerlink" title="Pygame"></a>Pygame</h1><h2 id="对象-总体"><a href="#对象-总体" class="headerlink" title="对象(总体)"></a>对象(总体)</h2><h3 id="surface"><a href="#surface" class="headerlink" title="surface"></a>surface</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>fill(color,Rect)</td><td></td></tr><tr><td>blit(surface对象，绘制到的区域，surface中用于绘制的部分区域)</td><td>( ，[(x,y),Rect]，Rect)</td></tr><tr><td>get_width()</td><td></td></tr><tr><td>get_height()</td><td></td></tr><tr><td>get_size()</td><td>return (w,h)</td></tr><tr><td>get_rect()</td><td>return Rect</td></tr><tr><td>subsurface(Rect)</td><td>创建子Surface</td></tr></tbody></table><h4 id="pygame-display-窗口图层"><a href="#pygame-display-窗口图层" class="headerlink" title="pygame.display(窗口图层)"></a>pygame.display(窗口图层)</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>set_mode(size,flags,depth)</td><td><code>size</code>:(x,y)  <code>flags</code>:创建模式，[pygame.FULLSCREEN(全屏)，pygame.HWSURFACE(硬件加速窗口图层)，pygame.OPENGL，pygame.RESIZABLE(可缩放窗口图层)，pygame.DOUBLEBUF(双缓冲区窗口)，pygame.NOFRAME(无边框窗口)]，<code>depth</code>:颜色位深</td></tr><tr><td>set_caption(title)</td><td></td></tr><tr><td>set_icon(Surface)</td><td></td></tr><tr><td>flip()</td><td>双缓冲区模式更新整个图层</td></tr><tr><td>update(Rect)</td><td>普通模式，可选区域</td></tr></tbody></table><h4 id="pygame-image"><a href="#pygame-image" class="headerlink" title="pygame.image"></a>pygame.image</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>load()</td><td></td></tr><tr><td>convert_alpha()</td><td>将Surface对象转换为带alpha通道的格式(可能更快)</td></tr><tr><td>scale(size)</td><td>返回一个尺寸为size的新Surface</td></tr><tr><td>rotate(angle)</td><td>返回一个旋转后的Surface，正逆负顺</td></tr><tr><td>rotozoom(angle,(x_rate，y_rate))</td><td>返回旋转且按比例放缩的Surface</td></tr></tbody></table><h4 id="pygame-draw"><a href="#pygame-draw" class="headerlink" title="pygame.draw"></a>pygame.draw</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>line()</td><td><code>surface</code>：要在其上绘制线条的<code>Surface</code>对象。  <code>color</code>：线条的颜色，通常是一个RGB元组，例如<code>(255, 0, 0)</code>表示红色。  <code>start_pos</code>：线条的起始位置，是一个元组<code>(x, y)</code>。  <code>end_pos</code>：线条的结束位置，也是一个元组<code>(x, y)</code>。  <code>width</code>（可选）：线条的宽度，默认为1。</td></tr><tr><td>lines()</td><td><code>surface</code>：要在其上绘制线条的<code>Surface</code>对象。  <code>color</code>：线条的颜色，通常是一个RGB元组。  <code>closed</code>：一个布尔值，指示是否将线条的起点和终点相连以形成一个闭合形状。  <code>pointlist</code>：一个点的列表，每个点都是一个<code>(x, y)</code>元组，表示线条的顶点。  <code>width</code>（可选）：线条的宽度，默认为1</td></tr><tr><td>rect()</td><td><code>surface</code>：要在其上绘制矩形的<code>Surface</code>对象。  <code>color</code>：矩形的颜色，通常是一个RGB元组，例如<code>(255, 0, 0)</code>表示红色。  <code>rect</code>：一个<code>pygame.Rect</code>对象，表示要绘制的矩形的位置和尺寸。  <code>width</code>（可选）：矩形边框的宽度，默认为0，表示填充矩形。如果大于0，则表示绘制矩形边框的宽度</td></tr><tr><td>polygon()</td><td><code>surface</code>：要在其上绘制多边形的<code>Surface</code>对象。  <code>color</code>：多边形的颜色，通常是一个RGB元组，例如<code>(255, 0, 0)</code>表示红色。  <code>pointlist</code>：一个点的列表，每个点都是一个<code>(x, y)</code>元组，表示多边形的顶点。这些点应该按照顺序连接，最后一个点会自动与第一个点相连，以形成一个闭合的多边形。  <code>width</code>（可选）：多边形边框的宽度，默认为0，表示填充多边形。如果大于0，则表示绘制多边形边框的宽度。</td></tr><tr><td>circle()</td><td><code>surface</code>：要在其上绘制圆形的<code>Surface</code>对象。  <code>color</code>：圆形的颜色，通常是一个RGB元组，例如<code>(255, 0, 0)</code>表示红色。  <code>pos</code>：圆心的位置，是一个<code>(x, y)</code>元组。  <code>radius</code>：圆的半径。  <code>width</code>（可选）：圆形边框的宽度，默认为0，表示填充圆形。如果大于0，则表示绘制圆形边框的宽度。</td></tr><tr><td>ellipse()</td><td><code>surface</code>：要在其上绘制椭圆的<code>Surface</code>对象。  <code>color</code>：椭圆的颜色，通常是一个RGB元组，例如<code>(255, 0, 0)</code>表示红色。  <code>rect</code>：一个<code>pygame.Rect</code>对象，表示椭圆外接矩形的位置和尺寸。  <code>width</code>（可选）：椭圆边框的宽度，默认为0，表示填充椭圆。如果大于0，则表示绘制椭圆边框的宽度。</td></tr><tr><td>arc()</td><td><code>surface</code>：要在其上绘制圆弧的<code>Surface</code>对象。  <code>color</code>：圆弧的颜色，通常是一个RGB元组，例如<code>(255, 0, 0)</code>表示红色。  <code>rect</code>：一个<code>pygame.Rect</code>对象，表示圆弧外接矩形的位置和尺寸。  <code>start_angle</code>：圆弧的起始角度，以度为单位，0度表示正右方，顺时针方向增加。  <code>stop_angle</code>：圆弧的终止角度，以度为单位。  <code>width</code>（可选）：圆弧边框的宽度，默认为1，表示绘制圆弧边框的宽度。如果设置为0，则不会绘制圆弧，但可以用来填充圆弧所对应的扇形区域。</td></tr></tbody></table><h3 id="pygame-font"><a href="#pygame-font" class="headerlink" title="pygame.font"></a>pygame.font</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>SysFont()</td><td>返回字体对象   <code>name</code>：系统字体的名称。如果指定为<code>None</code>，pygame将使用默认的系统字体。  <code>size</code>：字体的大小，以像素为单位。  <code>bold</code>（可选）：是否启用粗体效果，默认为<code>False</code>。  <code>italic</code>（可选）：是否启用斜体效果，默认为<code>False</code>。</td></tr><tr><td>Font()</td><td>返回字体对象   <code>filename</code>：字体文件的路径，它可以是TrueType字体（<code>.ttf</code>）或OpenType字体（<code>.otf</code>）文件。  <code>size</code>：字体的大小，以像素为单位。</td></tr></tbody></table><h4 id="font对象"><a href="#font对象" class="headerlink" title="font对象"></a>font对象</h4><table><thead><tr><th>字体对象方法</th><th>说明</th></tr></thead><tbody><tr><td>set_bold(bool)</td><td>是否加粗</td></tr><tr><td>set_italic(bool)</td><td>是否倾斜</td></tr><tr><td>set_underlines()</td><td>是否添加下划线</td></tr><tr><td>render()</td><td>返回一个Surface对象，   <code>text</code>：要渲染的文本字符串。  <code>antialias</code>：一个布尔值，指定是否启用抗锯齿效果。如果设置为<code>True</code>，则文本边缘会更加平滑。  <code>color</code>：文本的颜色，通常是一个RGB元组，例如<code>(255, 255, 255)</code>表示白色。  <code>background</code>（可选）：文本的背景色，也是一个RGB元组。如果指定了背景色，渲染出的<code>Surface</code>对象将包含这个背景色</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="pygame-time"><a href="#pygame-time" class="headerlink" title="pygame.time"></a>pygame.time</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>get_tick</td><td>返回运行时间</td></tr><tr><td>wait()</td><td>等待一段时间(毫秒)</td></tr><tr><td>delay()</td><td></td></tr><tr><td>set_timer()</td><td>设置一个计时器，定时触发事件。   <code>eventid</code>：一个用户定义的事件ID，它必须是一个正整数。这个ID用于标识定时器事件，以便在事件队列中识别它。  <code>milliseconds</code>：定时器触发的时间间隔，以毫秒为单位。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#set_timer()示例</span><br><span class="hljs-keyword">import</span> pygame  <br><span class="hljs-keyword">import</span> sys  <br>  <br>pygame.init()  <br>  <br><span class="hljs-comment"># 创建一个窗口  </span><br>screen = pygame.display.set_mode((<span class="hljs-number">640</span>, <span class="hljs-number">480</span>))  <br>  <br><span class="hljs-comment"># 设置定时器事件ID和时间间隔  </span><br>TIMER_EVENT = pygame.USEREVENT + <span class="hljs-number">1</span>  <br>TIME_INTERVAL = <span class="hljs-number">1000</span>  <span class="hljs-comment"># 1秒  </span><br>  <br><span class="hljs-comment"># 创建定时器事件  </span><br>pygame.time.set_timer(TIMER_EVENT, TIME_INTERVAL)  <br>  <br><span class="hljs-comment"># 游戏循环  </span><br>running = <span class="hljs-literal">True</span>  <br><span class="hljs-keyword">while</span> running:  <br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():  <br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:  <br>            running = <span class="hljs-literal">False</span>  <br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == TIMER_EVENT:  <br>            <span class="hljs-comment"># 处理定时器事件  </span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;定时器事件触发！&quot;</span>)  <br>      <br>    <span class="hljs-comment"># 更新屏幕显示  </span><br>    pygame.display.flip()  <br>  <br>pygame.quit()  <br>sys.exit()<br></code></pre></td></tr></table></figure><p>Clock()  创建并返回Clock对象</p><h4 id="Clock对象"><a href="#Clock对象" class="headerlink" title="Clock对象"></a>Clock对象</h4><table><thead><tr><th>clock对象方法</th><th>说明</th></tr></thead><tbody><tr><td>tick(FPS)</td><td>设置FPS</td></tr><tr><td>get_fps()</td><td></td></tr></tbody></table><h3 id="pygame-event"><a href="#pygame-event" class="headerlink" title="pygame.event"></a>pygame.event</h3><table><thead><tr><th>类属性</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>类型标识符</td></tr><tr><td>dict</td><td>专有属性字典</td></tr></tbody></table><p>pygame.event.get()获取所有事件对象组成的列表。</p><h4 id="事件对象类型标识符"><a href="#事件对象类型标识符" class="headerlink" title="事件对象类型标识符"></a>事件对象类型标识符</h4><table><thead><tr><th align="center">类型标识符</th><th align="center">专有属性</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">pygame.QUIT</td><td align="center">无</td><td align="center">退出事件，当用户尝试关闭窗口时触发</td></tr><tr><td align="center">pygame.ACTIVEEVENT</td><td align="center">gain, state</td><td align="center">活动事件，与窗口的激活状态有关</td></tr><tr><td align="center">pygame.KEYDOWN</td><td align="center">unicode, key, mod</td><td align="center">键盘按键按下事件，包含按下的Unicode字符、按键代码和修饰键状态</td></tr><tr><td align="center">pygame.KEYUP</td><td align="center">key, mod</td><td align="center">键盘按键释放事件，包含按键代码和修饰键状态</td></tr><tr><td align="center">pygame.MOUSEMOTION</td><td align="center">pos, rel, buttons</td><td align="center">鼠标移动事件，包含当前位置、相对移动和按下的按钮状态</td></tr><tr><td align="center">pygame.MOUSEBUTTONDOWN</td><td align="center">pos, button</td><td align="center">鼠标按钮按下事件，包含按下时的位置和按钮编号</td></tr><tr><td align="center">pygame.MOUSEBUTTONUP</td><td align="center">pos, button</td><td align="center">鼠标按钮释放事件，包含释放时的位置和按钮编号</td></tr><tr><td align="center">pygame.JOYAXISMOTION</td><td align="center">joy, axis, value</td><td align="center">游戏手柄轴运动事件，包含手柄ID、轴编号和轴值</td></tr><tr><td align="center">pygame.JOYBALLMOTION</td><td align="center">joy, ball, rel</td><td align="center">游戏手柄球运动事件，包含手柄ID、球编号和相对运动值</td></tr><tr><td align="center">pygame.JOYHATMOTION</td><td align="center">joy, hat, value</td><td align="center">游戏手柄帽子（方向帽）运动事件，包含手柄ID、帽子编号和方向值</td></tr><tr><td align="center">pygame.JOYBUTTONDOWN</td><td align="center">joy, button</td><td align="center">游戏手柄按钮按下事件，包含手柄ID和按钮编号</td></tr><tr><td align="center">pygame.JOYBUTTONUP</td><td align="center">joy, button</td><td align="center">游戏手柄按钮释放事件，包含手柄ID和按钮编号</td></tr><tr><td align="center">pygame.VIDEORESIZE</td><td align="center">size, w, h</td><td align="center">视频窗口大小改变事件，包含新的窗口大小（宽高对）和单独的宽高值</td></tr><tr><td align="center">pygame.VIDEOEXPOSE</td><td align="center">无</td><td align="center">视频窗口暴露事件，通常不需要用户处理</td></tr><tr><td align="center">pygame.USEREVENT</td><td align="center">自定义属性</td><td align="center">用户自定义事件，类型标识符值应大于等于<code>pygame.USEREVENT</code>，用户可自定义属性和值</td></tr></tbody></table><p><strong>解释说明</strong>：</p><ul><li><strong>gain, state</strong>（ACTIVEEVENT）：<code>gain</code>属性表示窗口是否获得焦点，<code>state</code>属性表示窗口的激活状态（如最小化、最大化等）。</li><li><strong>unicode, key, mod</strong>（KEYDOWN&#x2F;KEYUP）：<code>unicode</code>属性包含按下的Unicode字符（对于非特殊键），<code>key</code>属性是按键的pygame常量代码，<code>mod</code>属性表示按下时是否同时按下了修饰键（如Ctrl、Shift等）。</li><li><strong>pos, rel, buttons</strong>（MOUSEMOTION）：<code>pos</code>属性表示鼠标的当前位置（窗口坐标系），<code>rel</code>属性表示自上次事件以来的相对移动，<code>buttons</code>属性表示当前按下的鼠标按钮状态。</li><li><strong>pos, button</strong>（MOUSEBUTTONDOWN&#x2F;MOUSEBUTTONUP）：<code>pos</code>属性表示事件触发时的鼠标位置，<code>button</code>属性是按下或释放的按钮编号。</li><li><strong>joy, axis, value</strong>（JOYAXISMOTION）：<code>joy</code>属性表示触发事件的手柄ID，<code>axis</code>属性是轴的编号，<code>value</code>属性是轴的位置值。</li><li><strong>size, w, h</strong>（VIDEORESIZE）：<code>size</code>属性是一个包含新窗口宽度和高度的元组，<code>w</code>和<code>h</code>属性分别是新的窗口宽度和高度。</li><li><strong>自定义属性</strong>（USEREVENT）：用户自定义事件可以包含任何自定义的属性名和值，用于在程序中传递自定义信息。</li></ul><h4 id="窗口事件"><a href="#窗口事件" class="headerlink" title="窗口事件"></a>窗口事件</h4><table><thead><tr><th align="left">事件类型</th><th>事件描述</th><th>详细解释</th></tr></thead><tbody><tr><td align="left">pygame.QUIT</td><td>用户尝试关闭窗口时触发的事件</td><td>当用户点击窗口的关闭按钮或按下特定的关闭快捷键时，pygame会触发QUIT事件。在事件循环中捕获此事件，可以安全地退出游戏或应用程序。</td></tr><tr><td align="left">pygame.WINDOWEVENT</td><td>与窗口相关的事件，如窗口创建、销毁、移动、调整大小等</td><td>WINDOWEVENT是一个通用的事件类型，用于表示与窗口相关的各种事件。它包含多个子类型，如WINDOWEVENT_CLOSE（窗口关闭）、WINDOWEVENT_RESIZED（窗口大小调整）、WINDOWEVENT_MOVED（窗口移动）等。通过检查WINDOWEVENT的事件子类型，可以对窗口的不同状态变化做出响应。</td></tr><tr><td align="left">pygame.VIDEORESIZE</td><td>窗口大小改变时触发的事件</td><td>当用户调整窗口大小时，pygame会触发VIDEORESIZE事件。此事件包含新的窗口尺寸信息，允许程序根据新的窗口大小调整渲染区域或游戏逻辑。</td></tr></tbody></table><p><strong>详细解释补充</strong>：</p><ol><li><p><strong>pygame.QUIT</strong></p><ul><li><strong>背景</strong>：在pygame程序中，用户可能随时想要退出游戏或应用程序。</li><li><strong>过程</strong>：当用户点击窗口的关闭按钮（通常位于窗口的右上角）或按下系统指定的关闭快捷键（如Alt+F4）时，操作系统会通知pygame窗口即将关闭。</li><li><strong>影响</strong>：pygame捕捉到QUIT事件后，程序应该执行清理操作（如释放资源、保存游戏状态等），并通过调用<code>pygame.quit()</code>和<code>sys.exit()</code>安全地退出。</li></ul></li><li><p><strong>pygame.WINDOWEVENT</strong></p><ul><li><strong>背景</strong>：窗口是pygame程序与用户交互的主要界面，窗口的状态变化（如移动、调整大小、获得&#x2F;失去焦点等）会影响用户的游戏体验。</li><li><strong>过程</strong>：当窗口发生状态变化时，pygame会将这些变化封装为WINDOWEVENT事件，并放入事件队列中。程序通过检查事件队列中的事件，可以获取窗口的最新状态。</li><li><strong>影响</strong>：根据WINDOWEVENT的事件子类型，程序可以做出相应的响应。例如，如果窗口被关闭，程序可以执行退出操作；如果窗口大小被调整，程序可以重新调整渲染区域以适应新的窗口尺寸。</li></ul></li><li><p><strong>pygame.VIDEORESIZE</strong></p><ul><li><strong>背景</strong>：用户可能希望根据自己的屏幕分辨率或偏好调整pygame窗口的大小。</li><li><strong>过程</strong>：当用户拖动窗口的边缘以改变其大小时，pygame会检测到这一变化，并触发VIDEORESIZE事件。此事件包含新的窗口宽度和高度信息。</li><li><strong>影响</strong>：程序捕捉到VIDEORESIZE事件后，可以根据新的窗口尺寸重新调整游戏画面或渲染区域的大小，以确保游戏内容能够正确地显示在窗口中。这有助于提升用户体验和游戏的可访问性。</li></ul></li></ol><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><table><thead><tr><th align="center">事件类型</th><th align="center">事件描述</th><th align="center">详细解释</th></tr></thead><tbody><tr><td align="center">pygame.KEYDOWN</td><td align="center">键盘按键按下事件</td><td align="center">当用户按下键盘上的任何按键时，pygame会触发KEYDOWN事件。此事件包含多个属性，如<code>unicode</code>（按键的Unicode字符，但通常不推荐使用，因为它依赖于平台）、<code>key</code>（按键的常量名称，是一个整数值，pygame提供了如<code>K_a</code>、<code>K_LEFT</code>等常量来表示不同的按键）、<code>mod</code>（按键修饰符的组合值，用于表示是否同时按下了如Ctrl、Shift、Alt等修饰键）。通过检查这些属性，程序可以识别用户按下了哪个按键，并根据需要做出响应。</td></tr><tr><td align="center">pygame.KEYUP</td><td align="center">键盘按键释放事件</td><td align="center">当用户释放之前按下的键盘按键时，pygame会触发KEYUP事件。与KEYDOWN事件类似，KEYUP事件也包含<code>key</code>和<code>mod</code>属性，但通常不包含<code>unicode</code>属性，因为释放按键时不需要知道按键对应的Unicode字符。通过捕获KEYUP事件，程序可以知道用户何时停止了按键操作，这对于实现如长按检测等功能非常有用。</td></tr></tbody></table><p><strong>详细解释补充</strong>：</p><ul><li><p><strong>pygame.KEYDOWN事件</strong>：</p><ul><li>当用户按下键盘上的按键时，pygame会将该事件放入事件队列中。程序通过遍历事件队列并检查事件类型，可以识别出KEYDOWN事件。</li><li><code>key</code>属性是识别具体按键的关键。pygame提供了一系列的常量来表示不同的按键，如字母键（<code>K_a</code>、<code>K_b</code>等）、方向键（<code>K_LEFT</code>、<code>K_RIGHT</code>等）和功能键（如<code>K_ESCAPE</code>）。</li><li><code>mod</code>属性用于表示按键时是否同时按下了修饰键。pygame提供了如<code>KMOD_CTRL</code>、<code>KMOD_SHIFT</code>、<code>KMOD_ALT</code>等常量来表示不同的修饰键。通过检查<code>mod</code>属性与这些常量的按位与运算结果，可以确定是否按下了特定的修饰键组合。</li></ul></li><li><p><strong>pygame.KEYUP事件</strong>：</p><ul><li>与KEYDOWN事件相对应，当用户释放按键时，pygame会触发KEYUP事件。</li><li>通过捕获KEYUP事件，程序可以知道用户何时停止了按键操作。这对于实现如连续射击、长按加速等功能至关重要，因为它允许程序在用户停止按键时停止相应的操作。</li><li><code>key</code>和<code>mod</code>属性的作用与KEYDOWN事件中相同，分别用于表示释放的按键和同时按下的修饰键组合。</li></ul></li></ul><h5 id="key属性值"><a href="#key属性值" class="headerlink" title="key属性值"></a>key属性值</h5><table><thead><tr><th><code>key</code>属性值</th><th>按键名称</th><th>描述</th></tr></thead><tbody><tr><td><code>K_BACKSPACE</code></td><td>Backspace</td><td>退格键，用于删除光标前的字符</td></tr><tr><td><code>K_TAB</code></td><td>Tab</td><td>制表键，用于在不同字段间移动光标</td></tr><tr><td><code>K_RETURN</code></td><td>Enter</td><td>回车键，用于确认输入或换行</td></tr><tr><td><code>K_ESCAPE</code></td><td>Escape</td><td>退出键，常用于取消操作或退出程序</td></tr><tr><td><code>K_SPACE</code></td><td>Space</td><td>空格键</td></tr><tr><td><code>K_LEFT</code></td><td>Left Arrow</td><td>向左键</td></tr><tr><td><code>K_RIGHT</code></td><td>Right Arrow</td><td>向右键</td></tr><tr><td><code>K_UP</code></td><td>Up Arrow</td><td>向上键</td></tr><tr><td><code>K_DOWN</code></td><td>Down Arrow</td><td>向下键</td></tr><tr><td><code>K_a</code> 到 <code>K_z</code></td><td>A 到 Z</td><td>英文字母键</td></tr><tr><td><code>K_0</code> 到 <code>K_9</code></td><td>0 到 9</td><td>数字键</td></tr><tr><td><code>K_KP0</code> 到 <code>K_KP9</code></td><td>Keypad 0 到 9</td><td>小键盘上的数字键</td></tr><tr><td><code>K_F1</code> 到 <code>K_F12</code></td><td>F1 到 F12</td><td>功能键，常用于快捷操作</td></tr><tr><td><code>K_LSHIFT</code>, <code>K_RSHIFT</code></td><td>Left Shift, Right Shift</td><td>左右Shift键，用于输入大写字母或特殊符号</td></tr><tr><td><code>K_LCTRL</code>, <code>K_RCTRL</code></td><td>Left Ctrl, Right Ctrl</td><td>左右Ctrl键，常用于组合快捷键</td></tr><tr><td><code>K_LALT</code>, <code>K_RALT</code></td><td>Left Alt, Right Alt</td><td>左右Alt键，常用于组合快捷键</td></tr><tr><td><code>K_DELETE</code></td><td>Delete</td><td>删除键，用于删除选中的内容</td></tr></tbody></table><p><code>key</code>属性是在pygame的KEYDOWN和KEYUP事件中使用的，用于标识被按下或释放的按键。当这些事件发生时，可以通过检查事件的<code>key</code>属性来确定是哪个按键被操作，并据此编写相应的响应逻辑。</p><p>在pygame中处理键盘事件时，通常会结合使用<code>pygame.key.get_pressed()</code>函数和事件监听来获取按键状态。<code>pygame.key.get_pressed()</code>函数会返回一个序列，表示当前所有按键的状态（按下为True，未按下为False），而事件监听则允许程序响应按键的按下和释放动作。</p><h5 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h5><p>以下是一个关于pygame鼠标事件的详细解释表格：</p><table><thead><tr><th>事件代码</th><th>事件描述</th><th>详细解释</th></tr></thead><tbody><tr><td>pygame.<br />MOUSEMOTION</td><td>鼠标移动事件</td><td>当鼠标在窗口中移动时触发。事件包含<code>pos</code>（鼠标当前坐标值，相对于窗口左上角的(x, y)坐标）、<code>rel</code>（鼠标相对于上一次事件的移动距离，也是一个(x, y)坐标值）和<code>buttons</code>（鼠标按钮状态，一个包含三个数字的元组，分别代表左键、中键（滚轮）、右键的状态，状态值为0或1，表示按钮是否按下）属性。通过处理这个事件，可以实现如跟随鼠标移动的效果、实时显示鼠标坐标等功能。</td></tr><tr><td>pygame.<br />MOUSEBUTTONDOWN</td><td>鼠标按键按下事件</td><td>当用户按下鼠标触发。事件包含<code>pos</code>（鼠标当前坐标值）和<code>button</code>（被按下的鼠标按钮编号，左键为1，中键为2，右键为3，向上滚动滚轮为4，向下滚动滚轮为5）属性。</td></tr><tr><td>pygame.<br />MOUSEBUTTONUP</td><td>鼠标按键释放事件</td><td>当用户释放鼠标触发。事件包含<code>pos</code>（鼠标当前坐标值）和<code>button</code>（被释放的鼠标按钮编号，与MOUSEBUTTONDOWN事件中的<code>button</code>属性相同）属性。</td></tr></tbody></table><p><code>pygame.mouse.get_pressed()</code>用于获取当前所有鼠标按键的状态，返回一个由3个0&#x2F;1组成的元组</p><p><code>pygame.mouse.get_pos()</code>用于获取当前鼠标的位置。返回光标坐标。</p><h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Event(type,dict)</td><td><code>type</code>：这是一个整数或者pygame中定义的事件类型常量，比如<code>pygame.QUIT</code>、<code>pygame.KEYDOWN</code>等。它指定了新创建事件的类型。  <code>dict</code>：这是一个字典，包含了事件的属性。不同的事件类型有不同的属性集。比如，对于<code>pygame.KEYDOWN</code>事件，你可以包含<code>key</code>和<code>mod</code>属性；对于<code>pygame.MOUSEBUTTONDOWN</code>事件，你可以包含<code>pos</code>和<code>button</code>属性。<strong>该值应高于pygame.USEREVENT</strong></td></tr><tr><td>post(event)</td><td>将自定义事件加入事件队列</td></tr></tbody></table><h3 id="pygame-sprite"><a href="#pygame-sprite" class="headerlink" title="pygame.sprite"></a>pygame.sprite</h3><h4 id="Sprite类"><a href="#Sprite类" class="headerlink" title="Sprite类"></a>Sprite类</h4><table><thead><tr><th>Sprite类属性</th><th>说明</th></tr></thead><tbody><tr><td>image</td><td></td></tr><tr><td>rect</td><td></td></tr><tr><td>mask</td><td></td></tr></tbody></table><table><thead><tr><th>Sprite类方法</th><th>说明</th></tr></thead><tbody><tr><td>update()</td><td>更新状态</td></tr><tr><td>add()</td><td>将该精灵添加至精灵组</td></tr><tr><td>remove()</td><td>从精灵组中删除精灵</td></tr><tr><td>kill()</td><td>将精灵从其属于的所有精灵组删除</td></tr><tr><td>alive()</td><td>判断该精灵是否属于任意精灵组</td></tr><tr><td>groups()</td><td>返回该精灵所属的所有精灵组组成的列表</td></tr></tbody></table><h4 id="Group类"><a href="#Group类" class="headerlink" title="Group类"></a>Group类</h4><table><thead><tr><th>Group类方法</th><th>说明</th></tr></thead><tbody><tr><td>update()</td><td>更新组内所有精灵的状态</td></tr><tr><td>add()</td><td>将指定精灵拉进来</td></tr><tr><td>remove()</td><td>将指定精灵踢出去</td></tr><tr><td>empty()</td><td>清空</td></tr><tr><td>sprites()</td><td>用列表返回所有精灵</td></tr><tr><td>has()</td><td>判断组内有没有某精灵</td></tr><tr><td>draw()</td><td>绘制全部精灵</td></tr></tbody></table><h4 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>spritecollide(sprite,group,dokill,collided)</td><td>检查源精灵是否与另一个精灵组中的任何精灵发生碰撞。如果发生碰撞，<code>spritecollide()</code> 会返回一个包含所有与源精灵碰撞的精灵的列表<br /><code>sprite</code>：要进行碰撞检测的源精灵。  <br /><code>group</code>：要与之进行碰撞检测的精灵组。  <br /><code>dokill</code>：一个布尔值，如果设置为True，则在发生碰撞时，会从精灵组中删除碰撞的精灵。  <code>collided</code>：一个可选的碰撞回调函数。collide_rect()矩形检测、collide_circle圆形检测、collidemask()像素蒙版检测。</td></tr><tr><td>spritecollideany(sprite,group,collided)</td><td>返回第一个与源精灵碰撞的精灵</td></tr><tr><td>groupcollide()</td><td>返回一个字典，其中包含了所有发生碰撞的精灵对。<br /><code>group1</code>：第一个要进行碰撞检测的精灵组。<br />  <code>group2</code>：第二个要进行碰撞检测的精灵组。<br />  <code>dokill1</code>：一个布尔值，如果设置为 True，则在发生碰撞时，会从 <code>group1</code> 中删除碰撞的精灵。<br />  <code>dokill2</code>：一个布尔值，如果设置为 True，则在发生碰撞时，会从 <code>group2</code> 中删除碰撞的精灵。 <br /> <code>collided</code>：一个可选的碰撞回调函数，用于自定义碰撞检测的逻辑。如果提供了这个函数，它将被用来代替默认的碰撞检测逻辑</td></tr></tbody></table><h3 id="pygame-mixer"><a href="#pygame-mixer" class="headerlink" title="pygame.mixer"></a>pygame.mixer</h3><h4 id="创建音效对象"><a href="#创建音效对象" class="headerlink" title="创建音效对象"></a>创建音效对象</h4><p>pygame.mixer.Sound(filename)</p><h4 id="音效对象方法"><a href="#音效对象方法" class="headerlink" title="音效对象方法"></a>音效对象方法</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>play()</td><td>播放音效</td></tr></tbody></table><h3 id="Rect"><a href="#Rect" class="headerlink" title="Rect"></a>Rect</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td></td></tr><tr><td>y</td><td></td></tr><tr><td>left</td><td></td></tr><tr><td>right</td><td></td></tr><tr><td>top</td><td></td></tr><tr><td>bottom</td><td></td></tr><tr><td>width(简写w)</td><td></td></tr><tr><td>height(简写h)</td><td></td></tr><tr><td>size</td><td>(w,h)</td></tr><tr><td>centerx</td><td></td></tr><tr><td>centery</td><td></td></tr><tr><td>center</td><td></td></tr><tr><td>topleft，bottomleft</td><td></td></tr><tr><td>topright,bottomright</td><td></td></tr><tr><td>midtop,,midbottom,midleft,midright</td><td></td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>move(x,y)</td><td>返回新Rect,不改旧Rect</td></tr><tr><td>move_ip(x,y)</td><td>无返回值，改旧Rect</td></tr><tr><td>inflate(x,y)</td><td>宽+x,高+y,不改旧Rect</td></tr><tr><td>inflate_ip()</td><td>改旧Rect</td></tr><tr><td>contains(Rect)</td><td>检测调用此方法的Rect是否包含参数Rect， return bool</td></tr><tr><td>collidepoint(x,y)</td><td>检测(x,y)是否在Rect内，return bool</td></tr><tr><td>colliderect(Rect)</td><td>检测两Rect是否重叠，return bool</td></tr><tr><td>collidelist([Rect1,Rect2,…])</td><td>检测Rect是否与列表中Rect重叠，返回首个重叠的Rect的索引，否则返回-1</td></tr><tr><td>collidelistall([Rect1,Rect2,…])</td><td>若碰撞，返回列表</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/27/Nginx/"/>
    <url>/2024/10/27/Nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/27/MySQL/"/>
    <url>/2024/10/27/MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="数据库常识"><a href="#数据库常识" class="headerlink" title="数据库常识"></a>数据库常识</h2><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>以二维表描述数据</p><table><thead><tr><th>术语</th><th>说明</th></tr></thead><tbody><tr><td>关系</td><td>一个二维表就是一个关系</td></tr><tr><td>元组</td><td>一行</td></tr><tr><td>属性</td><td>一列</td></tr><tr><td>域</td><td>属性取值范围</td></tr></tbody></table><table><thead><tr><th>数据约束</th><th>说明</th></tr></thead><tbody><tr><td>实体完整性约束</td><td>约束关系主键值非空</td></tr><tr><td>参照完整性约束</td><td>关系之间的基本约束</td></tr><tr><td>用户定义的完整性约束</td><td></td></tr></tbody></table><h3 id="关系数据库的规范化"><a href="#关系数据库的规范化" class="headerlink" title="关系数据库的规范化"></a>关系数据库的规范化</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><ol><li>每个属性只有一值</li><li>关系中每个数组包含相同数量的值</li><li>关系中每个数组一定不同</li></ol><p>表中每一列都是不可再分的基本数据项，每行每列只能存一个属性</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>每个实体(一行)必须可以被唯一地区分，要设置”区分列”(主键)</p><p>实体的属性完全依赖于主键，不能存在只依赖主键一部分的属性，若存在，则要将其分离出来作为一个新的实体。新实体和原实体是一对多关系</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>不存在非关键字列对任意候选关键字列的传递函数依赖。</p><p>若关系表中存在关键字段A——&gt;非关键字段B——&gt;非关键字段C</p><p>应改为关键字段A——&gt;非关键字段B两个表<br>        非关键字段B——&gt;非关键字段C</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol><li>数据最大程度共享，最小冗余度，数据有效分离</li><li>保证输入和修改数据时的一致性与正确性</li><li>保证数据与使用数据的应用程序之间的高度独立性</li></ol><h3 id="实体与关系"><a href="#实体与关系" class="headerlink" title="实体与关系"></a>实体与关系</h3><table><thead><tr><th>关系</th><th>说明</th></tr></thead><tbody><tr><td>一对一</td><td>表A的一条记录在表B中只有一条相匹配的记录</td></tr><tr><td>一对多</td><td></td></tr><tr><td>多对多</td><td>靠建立连接表实现</td></tr></tbody></table><h3 id="数据库的体系结构"><a href="#数据库的体系结构" class="headerlink" title="数据库的体系结构"></a>数据库的体系结构</h3><table><thead><tr><th>三级模式结构</th><th>说明</th></tr></thead><tbody><tr><td>模式(逻辑模式)</td><td><strong>全体</strong>数据的<strong>逻辑结构和特征</strong>的描述(唯一)</td></tr><tr><td>外模式(用户模式)</td><td>用户能看见和使用的<strong>局部</strong>数据<strong>逻辑结构和特征</strong>的描述(模式的子集，多个)</td></tr><tr><td>内模式(存储模式)</td><td>数据在数据库内部的表示方式</td></tr></tbody></table><table><thead><tr><th>三级模式之间的映射</th><th>说明</th></tr></thead><tbody><tr><td>外模式&#x2F;模式映射</td><td>一个模式有多个外模式，每个外模式有一个<code>外模式/模式映射</code>，保证数据与程序的逻辑独立性</td></tr><tr><td>模式&#x2F;内模式映射</td><td>唯一，定义逻辑结构与存储模式的对应关系，保证数据与程序的物理独立性</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/27/JavaScript/"/>
    <url>/2024/10/27/JavaScript/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/27/HTTP/"/>
    <url>/2024/10/27/HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="请求方法与状态码"><a href="#请求方法与状态码" class="headerlink" title="请求方法与状态码"></a>请求方法与状态码</h2><table><thead><tr><th>常用方法</th><th>说明</th></tr></thead><tbody><tr><td>GET</td><td>向服务器请求数据</td></tr><tr><td>POST</td><td>向服务器发送数据</td></tr><tr><td>HEAD</td><td>请求数据但没有响应体</td></tr><tr><td>PUT</td><td>请求服务器更新某资源</td></tr><tr><td>DELETE</td><td>请求服务器删除某资源</td></tr></tbody></table><table><thead><tr><th>状态码开头</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td>表示服务器收到请求正在处理</td></tr><tr><td>2xx</td><td>表示成功</td></tr><tr><td>3xx</td><td>表示重定向</td></tr><tr><td>4xx</td><td>表示客户端错误(请求有误等)</td></tr><tr><td>5xx</td><td>表示服务器错误</td></tr></tbody></table><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>将域名、主机名解析成IP地址</p><h4 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h4><p>生成针对服务器的HTTP报文</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>将HTTP请求报文分割成报文段</p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>搜索对方地址，边中转边传送</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><h4 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h4><p>接收报文段，按照序号重组请求报文</p><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP"></a>HTTP</h4><p>处理请求内容</p><h4 id="回传"><a href="#回传" class="headerlink" title="回传"></a>回传</h4><p>TCP-&gt;IP-&gt;TCP-&gt;客户端</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>统一资源定位符，网页地址</p><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>统一资源标识符</p><p>格式：![幕截图_23-9-2024_9511](D:\important thing\笔记\images\屏幕截图_23-9-2024_9511_.jpeg)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/27/CMake/"/>
    <url>/2024/10/27/CMake/</url>
    
    <content type="html"><![CDATA[<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><h2 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p><strong>目标</strong>通常指的是需要构建的最终产物，比如可执行文件、库文件等。每个目  标都有一组与之相关联的源文件、依赖关系、编译选项等。</p><h3 id="变量与函数"><a href="#变量与函数" class="headerlink" title="变量与函数"></a>变量与函数</h3><p><code>$&#123;&#125;</code>表示一个变量</p><table><thead><tr><th>常用自动定义变量</th><th>说明</th></tr></thead><tbody><tr><td><code>$&#123;PROJECT_NAME&#125;</code></td><td>代指项目名</td></tr><tr><td><code>$&#123;PROJECT_BINARY_DIR&#125;</code></td><td>表示项目的二进制路径，exe文件会在此路径下生成</td></tr><tr><td><code>$&#123;PROJECT_SOURCE_DIR&#125;</code></td><td>代指当前项目的源代码目录<br />注意：在子目录的CMakeList.txt中，其指向的仍是顶级目录的源代码目录</td></tr><tr><td><code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</code></td><td>当前CMakeList.txt所在目录</td></tr><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>常用函数</th><th>说明</th></tr></thead><tbody><tr><td><code>TIMESTAMP</code></td><td>获取当前的时间戳，并将其格式化为指定的格式。</td></tr></tbody></table><h3 id="CMake变量占位符"><a href="#CMake变量占位符" class="headerlink" title="CMake变量占位符"></a>CMake变量占位符</h3><p>在头文件中，形如<code>@name@</code>的为<strong>CMake变量占位符</strong>，它们将在CMake配置阶段被替换为实际的值。</p><h3 id="软件版本号构成"><a href="#软件版本号构成" class="headerlink" title="软件版本号构成"></a><strong>软件版本号构成</strong></h3><ol><li><strong>主要部分（major）</strong>：这是版本号中的第一部分，通常表示软件的主要版本或发行版。当主要部分发生变化时，通常意味着软件进行了重大的更新或改进，可能包括新的功能、用户界面更改或底层架构的改进。这种变化可能会对软件的兼容性和用户体验产生显著影响。</li><li><strong>次要部分（minor）</strong>：这是版本号中的第二部分，用于表示在主要版本下的次要更新或修订。次要更新通常包括性能改进、小功能添加或错误修复，这些更改通常不会破坏软件的兼容性或用户的主要工作流程。</li><li><strong>修订号（patch）</strong>：这是版本号中的第三部分，用于表示对软件的微小修订或错误修复。修订号的变化通常意味着软件中的一些小问题或漏洞已经被修复，而这些修复通常不会对软件的主要功能或用户体验产生显著影响。</li></ol><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h3><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>PRIVATE</td><td>包含目录仅对当前目标可见，不会传递给依赖该目标的其他目标。</td></tr><tr><td>INTERFACE</td><td>包含目录对当前目标不可见，但会传递给依赖该目标的其他目标。这通常用于库目标，以导出其公共头文件。( 消费者需要、但生产者不需要)</td></tr><tr><td>PUBLIC</td><td>包含目录对当前目标可见，并且也会传递给依赖该目标的其他目标。这通常用于同时需要包含目录进行编译和导出其头文件的情况。</td></tr></tbody></table><h3 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h3><p><strong>静态库</strong>在<strong>链接阶段</strong>会被链接到最终目标中（比如可执行程序）</p><p>缺点：同一个静态库如果被不同的程序引用，那么内存中会存在这个静态库函数的多份拷贝。</p><p><strong>动态库</strong>在链接阶段不会被拷贝最终目标中，程序在<strong>运行阶段</strong>才会加载这个动态库。</p><p>优点：多个程序就算引用了同一个动态库，内存中也只存在一份动态库函数的拷贝。</p><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION )   <span class="hljs-comment">#指定最低CMake版本号</span><br><br><span class="hljs-keyword">project</span>(name)  <span class="hljs-comment">#设置项目名称</span><br><br><span class="hljs-keyword">add_executable</span>(a.cpp)  <span class="hljs-comment">#生成exe</span><br></code></pre></td></tr></table></figure><h3 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h3><h4 id="if-endif"><a href="#if-endif" class="headerlink" title="if() endif()"></a>if() endif()</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>(USE_MYMATH)<br>  <span class="hljs-keyword">add_subdirectory</span>(MathFunctions)<br>  <span class="hljs-keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)<br>  <span class="hljs-keyword">list</span>(APPEND EXTRA_INCLUDES <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/MathFunctions)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h4 id="foreach-endforeach"><a href="#foreach-endforeach" class="headerlink" title="foreach() endforeach()"></a>foreach() endforeach()</h4><p>类似Python中的for，foreach()有两种形式：</p><ul><li><p>遍历列表：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">foreach</span>(i in LISTS list_var)<br>...<br><span class="hljs-keyword">endforeach</span>()<br></code></pre></td></tr></table></figure></li><li><p>遍历范围：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">foreach</span>(i RANGE start stop [step])<br>...<br><span class="hljs-keyword">endforeach</span>()<br></code></pre></td></tr></table></figure></li></ul><h2 id="二、进阶"><a href="#二、进阶" class="headerlink" title="二、进阶"></a>二、进阶</h2><h3 id="set和PROJECT-NAME"><a href="#set和PROJECT-NAME" class="headerlink" title="set和PROJECT_NAME"></a>set和PROJECT_NAME</h3><p><code>$&#123;PROJECT_NAME&#125;</code>代指项目名，<code>$&#123;&#125;</code>表示一个变量</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> a.cpp b.cpp c.cpp)<br><span class="hljs-comment">#新建一个名称与项目名相同的exe,它由三个源文件组成</span><br><span class="hljs-comment">#多个源文件之间用空格隔开</span><br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(SRC_LIST a.cpp b.cpp c.cpp)<br><span class="hljs-comment">#设置一个名为SRC_LIST的变量，该变量表示三个源文件</span><br><span class="hljs-comment">#通过$&#123;SRC_LIST&#125;引用该变量</span><br></code></pre></td></tr></table></figure><p>于是上面的两个代码块可以这样写：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(SRC_LIST a.cpp b.cpp c.cpp)<br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="项目版本号和配置头文件"><a href="#项目版本号和配置头文件" class="headerlink" title="项目版本号和配置头文件"></a>项目版本号和配置头文件</h3><p>project()可以设置项目的版本号，例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">project</span>(Tutorial VERSION <span class="hljs-number">1.0</span>)<br></code></pre></td></tr></table></figure><h4 id="configure-file"><a href="#configure-file" class="headerlink" title="configure_file()"></a>configure_file()</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)<br><br><span class="hljs-comment">##configure_file(a.h.in b.h)用于复制a.h.in并粘贴至b.h，在复制过程中，如果a.h.in中定义了一些CMake变量，那么将会更新这些变量。</span><br><br><span class="hljs-comment">#.in只是一个表示这是输入文件的后缀</span><br><br>例如：<br>如果TutorialConfig.h.in中定义了项目版本号的CMake变量:<br><span class="hljs-comment">#define TUTORIAL_VERSION &quot;@TUTORIAL_VERSION@&quot;</span><br>那么在TutorialConfig.h重新生成时(复制后替换自身时)，@TUTORIAL_VERSION@ 将会替换成当前的项目版本号，<br>即：<br><span class="hljs-comment">#define TUTORIAL_VERSION &quot;1.0&quot;</span><br></code></pre></td></tr></table></figure><p><code>$&#123;PROJECT_BINARY_DIR&#125;</code>表示项目的二进制路径，exe文件会在此路径下生成</p><h4 id="target-include-directories"><a href="#target-include-directories" class="headerlink" title="target_include_directories()"></a>target_include_directories()</h4><p>target_include_directories(目标名 作用域 包含目录)  </p><p>为目标添加包含目录（使目标能访问目录里的文件，比如头文件）</p><p><code>作用域</code>：</p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>PRIVATE</td><td>包含目录仅对当前目标可见，不会传递给依赖该目标的其他目标。</td></tr><tr><td>INTERFACE</td><td>包含目录对当前目标不可见，但会传递给依赖该目标的其他目标。这通常用于库目标，以导出其公共头文件。</td></tr><tr><td>PUBLIC</td><td>包含目录对当前目标可见，并且也会传递给依赖该目标的其他目标。这通常用于同时需要包含目录进行编译和导出其头文件的情况。</td></tr></tbody></table><p>例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC<br>                           <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span><br>                           )                                 <span class="hljs-comment">#使得该项目能使用目录下的头文件或其他文件        </span><br></code></pre></td></tr></table></figure><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>创建一个用于控制版本和保存配置信息的头文件(后文将称之为配置头文件，一般与项目同名)，包含以下内容(示例)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// the configured options and settings for myproject</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> myproject_VERSION_MAJOR @PROJECT_VERSION_MAJOR@</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> myproject_VERSION_MINOR @PROJECT_VERSION_MINOR@</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> myproject_VERSION_PATCH @PROJECT_VERSION_PATCH@</span><br></code></pre></td></tr></table></figure><p>配置CMake时，用set()，configure_file()对该头文件重新生成。</p><p>后续运行时，可通过包含配置头文件，使用诸如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; Version &quot;</span> &lt;&lt; myproject_VERSION_MAJOR &lt;&lt; <span class="hljs-string">&quot;.&quot;</span>&lt;&lt; myproject_VERSION_MINOR &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>这样的代码打印版本号</p><h3 id="编译时间戳"><a href="#编译时间戳" class="headerlink" title="编译时间戳"></a>编译时间戳</h3><p>有时候我们需要知道编译时的时间戳，并在程序运行时打印出来。</p><h4 id="string"><a href="#string" class="headerlink" title="string()"></a>string()</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">string</span>(TIMESTAMP COMPILE_TIME %Y%m%d-%H%M%S)<br><span class="hljs-comment">#TIMESTAMP 用于获取时间戳</span><br><span class="hljs-comment">#COMPILE_TIME 是一个变量名</span><br><span class="hljs-comment">#%Y%m%d-%H%M%S 是一种时间格式</span><br><br><span class="hljs-comment">#整个string()的意思是生成一个格式为%Y%m%d-%H%M%S的格式化字符串的时间戳，并将其保存到COMPILE_TIME变量中</span><br></code></pre></td></tr></table></figure><p>在配置信息头文件中添加内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// the configured options and settings for myproject</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> myproject_VERSION_MAJOR @PROJECT_VERSION_MAJOR@</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> myproject_VERSION_MINOR @PROJECT_VERSION_MINOR@</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> myproject_VERSION_PATCH @PROJECT_VERSION_PATCH@</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMESTAMP @COMPILE_TIME@</span><br></code></pre></td></tr></table></figure><p>构建完后，会变为(示例)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMESTAMP 20230220-203532</span><br></code></pre></td></tr></table></figure><p>之后打印此值即可</p><h3 id="指定C-标准"><a href="#指定C-标准" class="headerlink" title="指定C++标准"></a>指定C++标准</h3><p>例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#设置C++标准为C++17</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-comment">#强制要求编译器必须支持参数CMAKE_CXX_STANDARD指定的C++标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">True</span>)<br><br></code></pre></td></tr></table></figure><p>从 GCC 6.1 开始，当不指定任何版本 C++ 标准时，默认版本是 C++ 14</p><h3 id="添加库"><a href="#添加库" class="headerlink" title="添加库"></a>添加库</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><h5 id="add-library"><a href="#add-library" class="headerlink" title="add_library()"></a>add_library()</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#库在名为MathFunctions的目录，目录中有同名头文件和一个源文件mysqrt.cpp</span><br><br><span class="hljs-comment">#添加一个叫 MathFunctions 的库文件。</span><br><span class="hljs-keyword">add_library</span>(MathFunctions mysqrt.cpp)<br><br><span class="hljs-comment">#add_library命令用于定义一个库。当执行add_library(MathFunctions mysqrt.cpp)时，CMake会创建一个名为MathFunctions的库，并将mysqrt.cpp文件编译为该库的一部分。</span><br><br><span class="hljs-comment">#一旦库被定义，就可以在其他目标（如可执行文件或其他库）中使用target_link_libraries命令来链接这个库。</span><br><br><span class="hljs-comment">#这里使用 add_library 命令生成的 MathFunctions 库是 静态链接库</span><br></code></pre></td></tr></table></figure><h5 id="add-subdirectory"><a href="#add-subdirectory" class="headerlink" title="add_subdirectory()"></a>add_subdirectory()</h5><p><code>add_subdirectory</code>命令用于向当前项目添加一个子目录。</p><h5 id="target-link-libraries"><a href="#target-link-libraries" class="headerlink" title="target_link_libraries()"></a>target_link_libraries()</h5><p><code>target_link_libraries</code>命令用于为指定的目标（如可执行文件或库）添加需要链接的库。</p><p>target_link_libraries(目标 作用域 一个或多个库)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(MyExecutable PRIVATE MathFunctions)<br></code></pre></td></tr></table></figure><h5 id="target-include-directories-1"><a href="#target-include-directories-1" class="headerlink" title="target_include_directories()"></a>target_include_directories()</h5><p><code>target_include_directories</code>命令用于为指定的目标（如可执行文件或库）添加包含目录。这些包含目录是编译器在查找头文件时应该搜索的路径。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_include_directories</span>(MyTarget PRIVATE <span class="hljs-keyword">include</span>)<br><span class="hljs-comment">#MyTarget是一个之前定义的目标（比如通过add_executable或add_library命令创建的可执行文件或库）</span><br><span class="hljs-comment">#include是一个相对于当前CMakeLists.txt文件的路径，指向包含头文件的目录。</span><br></code></pre></td></tr></table></figure><h4 id="流程示例"><a href="#流程示例" class="headerlink" title="流程示例"></a>流程示例</h4><ol><li><p>用<code>add_library(MathFuntions mysqrt.cpp)</code>创建一个名为MathFuntions的库，同时将mysqrt编译为库的一部分。</p></li><li><p>用<code>add_subdirectory(MathFunctions)</code>将库所在的目录添加为顶级目标的子目录。</p></li><li><p>用<code>add_executable()</code>为顶级目标生成exe</p></li><li><p>用<code>target_link_libraries()</code>使顶级目标链接MathFunctions库</p></li><li><p>用 <code>target_include_directories</code> 将 MathFunctions 添加为头文件目录</p><p>​</p><p>代码示例如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_subdirectory</span>(MathFunctions)<br><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> myproject.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC MathFunctions)<br><br><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC<br>                           <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span><br>                           <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/MathFunctions<br>                           )<br></code></pre></td></tr></table></figure><p>​</p></li></ol><h3 id="将库设置为可选项"><a href="#将库设置为可选项" class="headerlink" title="将库设置为可选项"></a>将库设置为可选项</h3><h4 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h4><h5 id="option"><a href="#option" class="headerlink" title="option()"></a>option()</h5><p>option(选项名称 选项描述(文档) 默认值(ON&#x2F;OFF))</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">option</span>(USE_MYMATH <span class="hljs-string">&quot;Use tutorial provided math implementation&quot;</span> <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment">#默认值若不指定则为OFF</span><br></code></pre></td></tr></table></figure><h5 id="list"><a href="#list" class="headerlink" title="list()"></a>list()</h5><p>list()用于操作列表变量</p><p>具体操作如下：</p><table><thead><tr><th>操作</th><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>创建或追加</td><td>list(APPEND <list_var> <element> [<element> …])</td><td>将一个或多个元素追加到名为 <code>&lt;list_var&gt;</code> 的列表变量中。如果列表不存在，它将被创建。</td></tr><tr><td>获取长度</td><td>list(LENGTH <list_var> <output_var>)</td><td>计算名为 <code>&lt;list_var&gt;</code> 的列表的长度，并将结果存储在 <code>&lt;output_var&gt;</code> 变量中。</td></tr><tr><td>获取元素</td><td>list(GET <list_var> <index> [<index> …] <output_var>)</td><td>从名为 <code>&lt;list_var&gt;</code> 的列表中获取一个或多个指定索引处的元素，并将结果存储在 <code>&lt;output_var&gt;</code> 变量中。索引是从 0 开始的。</td></tr><tr><td>插入元素</td><td>list(INSERT <list_var> <index> <element> [<element> …])</td><td>在名为 <code>&lt;list_var&gt;</code> 的列表的指定索引处插入一个或多个元素。</td></tr><tr><td>移除元素</td><td>list(REMOVE_ITEM <list_var> <value> [<value> …])<br />或者list(REMOVE_AT <list_var> <index> [<index> …])</td><td>这两个命令分别用于从名为 <code>&lt;list_var&gt;</code> 的列表中移除指定值或指定索引处的元素。</td></tr><tr><td>反转列表</td><td>list(REVERSE <list_var>)</td><td></td></tr><tr><td>排序</td><td>list(SORT <list_var>)</td><td>对名为 <code>&lt;list_var&gt;</code> 的列表进行排序</td></tr><tr><td>遍历</td><td>使用foreach()</td><td></td></tr></tbody></table><h4 id="流程示例-1"><a href="#流程示例-1" class="headerlink" title="流程示例"></a>流程示例</h4><p>1、修改CMakeList.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">option</span>(USE_MYMATH <span class="hljs-string">&quot;Use tutorial provided math implementation&quot;</span> <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-keyword">if</span>(USE_MYMATH)<br>  <span class="hljs-keyword">add_subdirectory</span>(MathFunctions)<br>  <br>  <span class="hljs-comment">#使用列表变量EXTRA_LIBS装所有要链接的库</span><br>  <span class="hljs-keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)<br>  <span class="hljs-comment">#使用列表变量EXTRA_INCLUDES装所有要链接的库所在的目录</span><br>  <span class="hljs-keyword">list</span>(APPEND EXTRA_INCLUDES <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/MathFunctions)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> myproject.cpp)<br><br><span class="hljs-comment">#链接EXTRA_LIBS中的所有库</span><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC <span class="hljs-variable">$&#123;EXTRA_LIBS&#125;</span>)<br><br><span class="hljs-comment">#使顶级目标包含EXTRA_INCLUDES中的所有目录</span><br><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC<br>                           <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span><br>                           <span class="hljs-variable">$&#123;EXTRA_INCLUDES&#125;</span><br>                           )<br></code></pre></td></tr></table></figure><p>2、在顶级目标源文件中添加预命令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_MYMATH</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MathFunctions.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>还可以添加优先选择逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_MYMATH</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">double</span> outputValue = <span class="hljs-built_in">mysqrt</span>(inputValue);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">const</span> <span class="hljs-type">double</span> outputValue = <span class="hljs-built_in">sqrt</span>(inputValue);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>3、修改配置头文件，添加定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// myproject.h.in</span><br><span class="hljs-meta">#cmakedefine USE_MYMATH</span><br></code></pre></td></tr></table></figure><h3 id="添加库的使用要求"><a href="#添加库的使用要求" class="headerlink" title="添加库的使用要求"></a>添加库的使用要求</h3><h4 id="基本命令-2"><a href="#基本命令-2" class="headerlink" title="基本命令"></a>基本命令</h4><h5 id="target-compile-definitions"><a href="#target-compile-definitions" class="headerlink" title="target_compile_definitions()"></a>target_compile_definitions()</h5><p>该命令用于为目标添加编译时定义。这些定义在编译时会被传递给编译器，通常用于设置宏或条件编译标志。</p><p>target_compile_definitions(<target> <definition> [<definition> …])</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_definitions</span>(MyTarget PRIVATE MY_MACRO)<br><span class="hljs-comment">#为目标 MyTarget 添加编译定义 MY_MACRO</span><br></code></pre></td></tr></table></figure><h5 id="target-compile-options"><a href="#target-compile-options" class="headerlink" title="target_compile_options()"></a><strong>target_compile_options()</strong></h5><p>为目标设置编译选项。这些选项会直接传递给编译器，允许你指定额外的编译标志，如优化级别、警告等级或调试信息等。</p><p>target_compile_options(<target> [BEFORE] <options> [<options> …])</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_options</span>(MyTarget PRIVATE -Wall -Wextra)<br><span class="hljs-comment">#为目标 MyTarget 添加编译选项 -Wall -Wextra</span><br></code></pre></td></tr></table></figure><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>在库的CMakeList.txt中加入这个：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># MathFunctions/CMakeLists.txt</span><br><span class="hljs-keyword">target_include_directories</span>(MathFunctions<br>          INTERFACE <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br>          )<br><span class="hljs-comment">#只要引用该库，顶级目标就会自动包含该库的目录</span><br><span class="hljs-comment">#所以上文中用于装目录的EXTRA_INCLUDES变量可以丢了</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
